From 98fbe7e58b695b27af80ae31bc1efbb15ea75872 Mon Sep 17 00:00:00 2001
From: Vasiliy Stelmachenok <ventureo@cachyos.org>
Date: Fri, 16 Jan 2026 00:01:30 +0300
Subject: [PATCH] Revert "wsi/wayland: Add support for PresentWait2"

This reverts commit 3023f31cadc9a384f0d72832bfca5e05ce0ce89c.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/vulkan/wsi/wsi_common_wayland.c | 70 -----------------------------
 1 file changed, 70 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index 083777f42ac..7f710e58e52 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -1888,32 +1888,6 @@ wsi_wl_surface_get_capabilities2(VkIcdSurfaceBase *surface,
          break;
       }
 
-      case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR: {
-         VkSurfaceCapabilitiesPresentId2KHR *pid2 = (void *)ext;
-         bool has_feedback;
-
-         result = wsi_wl_surface_check_presentation(surface, wsi_device,
-                                                    &has_feedback);
-         if (result != VK_SUCCESS)
-            return result;
-
-         pid2->presentId2Supported = has_feedback;
-         break;
-      }
-
-      case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR: {
-         VkSurfaceCapabilitiesPresentWait2KHR *pwait2 = (void *)ext;
-         bool has_feedback;
-
-         result = wsi_wl_surface_check_presentation(surface, wsi_device,
-                                                    &has_feedback);
-         if (result != VK_SUCCESS)
-            return result;
-
-         pwait2->presentWait2Supported = has_feedback;
-         break;
-      }
-
       default:
          /* Ignored */
          break;
@@ -2655,49 +2629,6 @@ already_dispatching:
    return ret;
 }
 
-static VkResult
-wsi_wl_swapchain_wait_for_present2(struct wsi_swapchain *wsi_chain,
-                                   uint64_t present_id,
-                                   uint64_t timeout)
-{
-   struct wsi_wl_swapchain *chain = (struct wsi_wl_swapchain *)wsi_chain;
-   struct timespec end_time;
-   VkResult ret;
-   int err;
-
-   MESA_TRACE_FUNC();
-
-   uint64_t atimeout;
-   if (timeout == 0 || timeout == UINT64_MAX)
-      atimeout = timeout;
-   else
-      atimeout = os_time_get_absolute_timeout(timeout);
-   timespec_from_nsec(&end_time, atimeout);
-
-   /* Need to observe that the swapchain semaphore has been unsignalled,
-    * as this is guaranteed when a present is complete. */
-   VkResult result = wsi_swapchain_wait_for_present_semaphore(
-         &chain->base, present_id, timeout);
-   if (result != VK_SUCCESS)
-      return result;
-
-   while (1) {
-      err = pthread_mutex_lock(&chain->present_ids.lock);
-      if (err != 0)
-         return VK_ERROR_OUT_OF_DATE_KHR;
-
-      bool completed = chain->present_ids.max_completed >= present_id;
-      pthread_mutex_unlock(&chain->present_ids.lock);
-
-      if (completed)
-         return VK_SUCCESS;
-
-      ret = dispatch_present_id_queue(wsi_chain, &end_time);
-      if (ret != VK_SUCCESS)
-         return ret;
-   }
-}
-
 static VkResult
 wsi_wl_swapchain_acquire_next_image_explicit(struct wsi_swapchain *wsi_chain,
                                              const VkAcquireNextImageInfoKHR *info,
@@ -3606,7 +3537,6 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->base.release_images = wsi_wl_swapchain_release_images;
    chain->base.set_present_mode = wsi_wl_swapchain_set_present_mode;
    chain->base.wait_for_present = wsi_wl_swapchain_wait_for_present;
-   chain->base.wait_for_present2 = wsi_wl_swapchain_wait_for_present2;
    chain->base.present_mode = present_mode;
    chain->base.image_count = num_images;
    chain->base.set_hdr_metadata = wsi_wl_swapchain_set_hdr_metadata;
-- 
2.53.0

