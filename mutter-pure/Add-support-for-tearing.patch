From ee41be90bd0af42ebfb9d98a56601eca368ac397 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 26 May 2025 14:55:01 +0000
Subject: [PATCH 1/8] build: Bump libdrm requirement to >= 2.4.120

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 meson.build | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/meson.build b/meson.build
index 201f29664a..820085beea 100644
--- a/meson.build
+++ b/meson.build
@@ -53,7 +53,7 @@ wayland_protocols_req = '>= 1.45'
 # native backend version requirements
 libinput_req = '>= 1.27.0'
 gbm_req = '>= 21.3'
-libdrm_req = '>= 2.4.118'
+libdrm_req = '>= 2.4.120'
 
 # screen cast version requirements
 libpipewire_req = '>= 1.2.7'
-- 
2.52.0


From 65c260523e8931c83c2531ebdabbe34955dcec8f Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Thu, 10 Apr 2025 04:27:46 +0000
Subject: [PATCH 2/8] atomic: Check for atomic tearing capability

Verify if the DRM device supports atomic async page flips.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-device.c      | 6 ++++++
 src/backends/native/meta-kms-device.h      | 3 +++
 src/backends/native/meta-kms-impl-device.c | 6 ++++++
 src/backends/native/meta-kms-impl-device.h | 1 +
 4 files changed, 16 insertions(+)

diff --git a/src/backends/native/meta-kms-device.c b/src/backends/native/meta-kms-device.c
index 4dec048d08..0ce4ccd0bd 100644
--- a/src/backends/native/meta-kms-device.c
+++ b/src/backends/native/meta-kms-device.c
@@ -140,6 +140,12 @@ meta_kms_device_uses_monotonic_clock (MetaKmsDevice *device)
   return device->caps.uses_monotonic_clock;
 }
 
+gboolean
+meta_kms_device_supports_async_page_flip (MetaKmsDevice *device)
+{
+  return device->caps.supports_async_page_flip;
+}
+
 GList *
 meta_kms_device_get_connectors (MetaKmsDevice *device)
 {
diff --git a/src/backends/native/meta-kms-device.h b/src/backends/native/meta-kms-device.h
index 6dfa5a76ac..49d68b19c0 100644
--- a/src/backends/native/meta-kms-device.h
+++ b/src/backends/native/meta-kms-device.h
@@ -51,6 +51,9 @@ gboolean meta_kms_device_prefers_shadow_buffer (MetaKmsDevice *device);
 META_EXPORT_TEST
 gboolean meta_kms_device_uses_monotonic_clock (MetaKmsDevice *device);
 
+META_EXPORT_TEST
+gboolean meta_kms_device_supports_async_page_flip (MetaKmsDevice *device);
+
 META_EXPORT_TEST
 GList * meta_kms_device_get_connectors (MetaKmsDevice *device);
 
diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index 4a53915dea..a936334ddb 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -558,6 +558,7 @@ init_caps (MetaKmsImplDevice *impl_device)
   uint64_t prefer_shadow;
   uint64_t uses_monotonic_clock;
   uint64_t addfb2_modifiers;
+  uint64_t async_page_flip_supported;
 
   fd = meta_device_file_get_fd (priv->device_file);
   if (drmGetCap (fd, DRM_CAP_CURSOR_WIDTH, &cursor_width) == 0 &&
@@ -585,6 +586,11 @@ init_caps (MetaKmsImplDevice *impl_device)
     {
       priv->caps.addfb2_modifiers = (addfb2_modifiers != 0);
     }
+
+  if (drmGetCap (fd, DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP, &async_page_flip_supported) == 0)
+    {
+      priv->caps.supports_async_page_flip = (async_page_flip_supported != 0);
+    }
 }
 
 static void
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index 22396dba68..20eb5d1e62 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -39,6 +39,7 @@ typedef struct _MetaKmsDeviceCaps
   gboolean uses_monotonic_clock;
   gboolean addfb2_modifiers;
   gboolean supports_color_modes;
+  gboolean supports_async_page_flip;
 } MetaKmsDeviceCaps;
 
 
-- 
2.52.0


From 30b9296526fb648b459c4eb515e4d9e6ceee99f6 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 14 Oct 2024 08:26:52 +0000
Subject: [PATCH 3/8] settings: Add experimental feature for tearing

Introduce an experimental feature for tearing, which can be
enabled by adding the "tearing" keyword under the "experimental-features"
GSetting. This requirement will be removed once the tearing design
is approved for general use and adequately addresses all common
use cases.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 data/org.gnome.mutter.gschema.xml.in       | 7 +++++++
 src/backends/meta-settings-private.h       | 1 +
 src/backends/meta-settings.c               | 3 +++
 src/backends/native/meta-onscreen-native.c | 9 +++++++++
 4 files changed, 20 insertions(+)

diff --git a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
index 3a8fd2bc31..4187fb0a79 100644
--- a/data/org.gnome.mutter.gschema.xml.in
+++ b/data/org.gnome.mutter.gschema.xml.in
@@ -6,6 +6,7 @@
     <value nick="autoclose-xwayland" value="4"/>
     <value nick="variable-refresh-rate" value="8"/>
     <value nick="xwayland-native-scaling" value="16"/>
+    <value nick="tearing" value="32"/>
   </flags>
 
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
@@ -143,6 +144,12 @@
                                         be unscaled. Setting only takes effect
                                         when “scale-monitor-framebuffer” is
                                         enabled as well.
+
+        • “tearing”                   — makes mutter change the presentation
+                                        to Async or Vsync when applicable and if
+                                        supported by the driver, Configurable in
+                                        Settings. Requires a restart.
+
       </description>
     </key>
 
diff --git a/src/backends/meta-settings-private.h b/src/backends/meta-settings-private.h
index 3141ec6b45..7516a2cb49 100644
--- a/src/backends/meta-settings-private.h
+++ b/src/backends/meta-settings-private.h
@@ -34,6 +34,7 @@ typedef enum _MetaExperimentalFeature
   META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 2),
   META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 3),
   META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING  = (1 << 4),
+  META_EXPERIMENTAL_FEATURE_TEARING = (1 << 5),
 } MetaExperimentalFeature;
 
 typedef enum _MetaXwaylandExtension
diff --git a/src/backends/meta-settings.c b/src/backends/meta-settings.c
index a8e4edf50e..c2aacddc71 100644
--- a/src/backends/meta-settings.c
+++ b/src/backends/meta-settings.c
@@ -49,6 +49,7 @@ static GDebugKey experimental_feature_keys[] = {
   { "autoclose-xwayland", META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND },
   { "variable-refresh-rate", META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE },
   { "xwayland-native-scaling", META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING },
+  { "tearing", META_EXPERIMENTAL_FEATURE_TEARING },
 };
 
 static guint signals[N_SIGNALS];
@@ -310,6 +311,8 @@ experimental_features_handler (GVariant *features_variant,
         feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
       else if (g_str_equal (feature_str, "xwayland-native-scaling"))
         feature = META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING;
+      else if (g_str_equal (feature_str, "tearing"))
+        feature = META_EXPERIMENTAL_FEATURE_TEARING;
 
       if (feature)
         g_message ("Enabling experimental feature '%s'", feature_str);
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index d91cd6b6dc..5f76e23ca9 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -126,6 +126,8 @@ struct _MetaOnscreenNative
   gboolean frame_sync_requested;
   gboolean frame_sync_enabled;
 
+  gboolean is_tearing_allowed;
+
   MetaRendererView *view;
 
   union {
@@ -2979,6 +2981,9 @@ meta_onscreen_native_new (MetaRendererNative *renderer_native,
                           int                 height)
 {
   MetaOnscreenNative *onscreen_native;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaSettings *settings = meta_backend_get_settings (backend);
   CoglFramebufferDriverConfig driver_config;
   const MetaOutputInfo *output_info = meta_output_get_info (output);
 
@@ -3016,6 +3021,10 @@ meta_onscreen_native_new (MetaRendererNative *renderer_native,
                           onscreen_native);
     }
 
+  onscreen_native->is_tearing_allowed =
+    meta_settings_is_experimental_feature_enabled (
+      settings, META_EXPERIMENTAL_FEATURE_TEARING);
+
   return onscreen_native;
 }
 
-- 
2.52.0


From e228ee000eb153cd09786db9734519cebddbf5aa Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Mon, 26 May 2025 15:02:14 +0000
Subject: [PATCH 4/8] wayland: Add support for tearing control protocol

Implement core support for the Wayland tearing control protocol,
enabling Wayland clients to request tearing or asynchronous page
flip functionality.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/meson.build                            |   3 +
 src/wayland/meta-wayland-surface-private.h |   4 +
 src/wayland/meta-wayland-surface.c         |  14 ++
 src/wayland/meta-wayland-tearing-control.c | 263 +++++++++++++++++++++
 src/wayland/meta-wayland-tearing-control.h |  39 +++
 src/wayland/meta-wayland-versions.h        |   1 +
 src/wayland/meta-wayland.c                 |   2 +
 7 files changed, 326 insertions(+)
 create mode 100644 src/wayland/meta-wayland-tearing-control.c
 create mode 100644 src/wayland/meta-wayland-tearing-control.h

diff --git a/src/meson.build b/src/meson.build
index 508c3416da..2b25ee126b 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -713,6 +713,8 @@ if have_wayland
     'wayland/meta-wayland-tablet-seat.h',
     'wayland/meta-wayland-tablet-tool.c',
     'wayland/meta-wayland-tablet-tool.h',
+    'wayland/meta-wayland-tearing-control.c',
+    'wayland/meta-wayland-tearing-control.h',
     'wayland/meta-wayland-text-input.c',
     'wayland/meta-wayland-text-input.h',
     'wayland/meta-wayland-toplevel-drag.c',
@@ -1179,6 +1181,7 @@ if have_wayland
     ['session-management-v1', 'private', ],
     ['single-pixel-buffer', 'staging', 1, ],
     ['tablet', 'stable', 2, ],
+    ['tearing-control', 'staging', 1, ],
     ['text-input', 'unstable', 3, ],
     ['viewporter', 'stable', ],
     ['xdg-activation', 'staging', 1, ],
diff --git a/src/wayland/meta-wayland-surface-private.h b/src/wayland/meta-wayland-surface-private.h
index 85332ddd03..19ae72f59d 100644
--- a/src/wayland/meta-wayland-surface-private.h
+++ b/src/wayland/meta-wayland-surface-private.h
@@ -154,6 +154,9 @@ struct _MetaWaylandSurfaceState
   MetaMultiTextureCoefficients coeffs;
   gboolean has_new_chroma_loc;
   MetaMultiTextureChromaLoc chroma_loc;
+
+  gboolean has_new_allow_tearing;
+  gboolean allow_tearing;
 };
 
 struct _MetaWaylandDragDestFuncs
@@ -221,6 +224,7 @@ struct _MetaWaylandSurface
     MetaMultiTextureAlphaMode premult;
     MetaMultiTextureCoefficients coeffs;
     MetaMultiTextureChromaLoc chroma_loc;
+    gboolean allow_tearing;
   } applied_state, committed_state;
 
   /* Extension resources. */
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index f01e65f14b..aeddd4de77 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -430,6 +430,7 @@ meta_wayland_surface_state_set_default (MetaWaylandSurfaceState *state)
   state->dx = 0;
   state->dy = 0;
   state->scale = 0;
+  state->has_new_allow_tearing = FALSE;
 
   state->input_region = NULL;
   state->input_region_set = FALSE;
@@ -602,6 +603,12 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
   if (from->scale > 0)
     to->scale = from->scale;
 
+  if (from->has_new_allow_tearing)
+    {
+      to->allow_tearing = from->allow_tearing;
+      to->has_new_allow_tearing = TRUE;
+    }
+
   if (from->has_new_buffer_transform)
     {
       to->buffer_transform = from->buffer_transform;
@@ -893,6 +900,8 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
 
   surface->applied_state.is_valid = surface->committed_state.is_valid;
 
+  surface->applied_state.allow_tearing = surface->committed_state.allow_tearing;
+
   if (surface->role)
     {
       meta_wayland_surface_role_pre_apply_state (surface->role, state);
@@ -1131,6 +1140,11 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
 
   surface->committed_state.is_valid = TRUE;
 
+  if (pending->has_new_allow_tearing)
+    {
+      surface->committed_state.allow_tearing = pending->allow_tearing;
+    }
+
   if (pending->scale > 0)
     surface->committed_state.scale = pending->scale;
 
diff --git a/src/wayland/meta-wayland-tearing-control.c b/src/wayland/meta-wayland-tearing-control.c
new file mode 100644
index 0000000000..dc0237c210
--- /dev/null
+++ b/src/wayland/meta-wayland-tearing-control.c
@@ -0,0 +1,263 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2025 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Naveen Kumar <naveen1.kumar@intel.com>
+ */
+
+#include "config.h"
+
+#include "wayland/meta-wayland-tearing-control.h"
+
+#include <wayland-server.h>
+
+#include "wayland/meta-wayland-private.h"
+#include "wayland/meta-wayland-surface-private.h"
+#include "wayland/meta-wayland-versions.h"
+
+#include "tearing-control-v1-server-protocol.h"
+
+static GQuark quark_tearing_surface_data = 0;
+
+typedef struct _MetaWaylandTearingSurface
+{
+  GObject parent_instance;
+
+  struct wl_resource *resource;
+  MetaWaylandSurface *surface;
+  gulong destroy_handler_id;
+} MetaWaylandTearingSurface;
+
+#define META_TYPE_WAYLAND_TEARING_SURFACE (meta_wayland_tearing_surface_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandTearingSurface,
+                      meta_wayland_tearing_surface,
+                      META, WAYLAND_TEARING_SURFACE,
+                      GObject)
+
+G_DEFINE_TYPE (MetaWaylandTearingSurface,
+               meta_wayland_tearing_surface,
+               G_TYPE_OBJECT)
+
+static void
+wp_tearing_control_set_presentation_hint (struct wl_client   *client,
+                                          struct wl_resource *resource,
+                                          uint32_t            hint_value)
+{
+  MetaWaylandTearingSurface *tearing_surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface = tearing_surface->surface;
+  MetaWaylandSurfaceState *pending;
+  enum wp_tearing_control_v1_presentation_hint hint = hint_value;
+
+  if (!surface)
+    return;
+
+  pending = meta_wayland_surface_get_pending_state (surface);
+  switch (hint)
+    {
+    case WP_TEARING_CONTROL_V1_PRESENTATION_HINT_ASYNC:
+      pending->allow_tearing = TRUE;
+      break;
+    case WP_TEARING_CONTROL_V1_PRESENTATION_HINT_VSYNC:
+      pending->allow_tearing = FALSE;
+      break;
+    default:
+      wl_resource_post_error (resource, WL_DISPLAY_ERROR_INVALID_METHOD,
+                              "Invalid argument: unknown presentation hint");
+      return;
+    }
+
+  pending->has_new_allow_tearing = TRUE;
+}
+
+static void
+wp_tearing_control_destroy (struct wl_client   *client,
+                            struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static const struct wp_tearing_control_v1_interface tearing_surface_interface = {
+  wp_tearing_control_set_presentation_hint,
+  wp_tearing_control_destroy,
+};
+
+static void
+wp_tearing_control_manager_destroy (struct wl_client   *client,
+                                    struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static void
+clear_tearing_surface_data (MetaWaylandTearingSurface *tearing_surface)
+{
+  MetaWaylandSurfaceState *pending;
+
+  if (tearing_surface->surface)
+    {
+      g_object_set_qdata (G_OBJECT (tearing_surface->surface),
+                          quark_tearing_surface_data, NULL);
+      g_clear_signal_handler (&tearing_surface->destroy_handler_id,
+                              tearing_surface->surface);
+
+      pending = meta_wayland_surface_get_pending_state (tearing_surface->surface);
+      pending->allow_tearing = FALSE;
+      pending->has_new_allow_tearing = FALSE;
+      tearing_surface->surface = NULL;
+    }
+}
+
+static void
+on_surface_destroyed (MetaWaylandSurface        *surface,
+                      MetaWaylandTearingSurface *tearing_surface)
+{
+  clear_tearing_surface_data (tearing_surface);
+}
+
+static void
+tearing_control_surface_destructor (struct wl_resource *resource)
+{
+  MetaWaylandTearingSurface *tearing_surface = wl_resource_get_user_data (resource);
+
+  clear_tearing_surface_data (tearing_surface);
+
+  g_object_unref (tearing_surface);
+}
+
+static void
+meta_wayland_tearing_surface_dispose (GObject *object)
+{
+  MetaWaylandTearingSurface *tearing_surface = META_WAYLAND_TEARING_SURFACE (object);
+
+  g_clear_signal_handler (&tearing_surface->destroy_handler_id,
+                          tearing_surface->surface);
+
+  G_OBJECT_CLASS (meta_wayland_tearing_surface_parent_class)->dispose (object);
+}
+
+static void
+meta_wayland_tearing_surface_init (MetaWaylandTearingSurface *tearing_surface)
+{
+}
+
+static void
+meta_wayland_tearing_surface_class_init (MetaWaylandTearingSurfaceClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_wayland_tearing_surface_dispose;
+}
+
+static MetaWaylandTearingSurface *
+meta_wayland_tearing_surface_new (MetaWaylandSurface *surface)
+{
+  MetaWaylandTearingSurface *tearing_surface;
+
+  tearing_surface = g_object_new (META_TYPE_WAYLAND_TEARING_SURFACE, NULL);
+  tearing_surface->surface = surface;
+
+  tearing_surface->destroy_handler_id =
+    g_signal_connect (tearing_surface->surface, "destroy",
+                      G_CALLBACK (on_surface_destroyed),
+                      tearing_surface);
+  return tearing_surface;
+}
+
+static void
+wp_tearing_control_manager_get_tearing_control (struct wl_client   *client,
+                                                struct wl_resource *resource,
+                                                uint32_t            id,
+                                                struct wl_resource *surface_resource)
+{
+  MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
+  g_autoptr (MetaWaylandTearingSurface) tearing_surface = NULL;
+  MetaWaylandTearingSurface *existing_tearing_surface;
+
+  existing_tearing_surface =
+    g_object_get_qdata (G_OBJECT (surface), quark_tearing_surface_data);
+
+  if (existing_tearing_surface)
+    {
+      wl_resource_post_error (resource,
+                              WP_TEARING_CONTROL_MANAGER_V1_ERROR_TEARING_CONTROL_EXISTS,
+                              "Surface already has a tearing controller");
+      return;
+    }
+
+  tearing_surface = meta_wayland_tearing_surface_new (surface);
+
+  tearing_surface->resource =
+    wl_resource_create (client,
+                        &wp_tearing_control_v1_interface,
+                        wl_resource_get_version (resource),
+                        id);
+
+  wl_resource_set_implementation (tearing_surface->resource,
+                                  &tearing_surface_interface,
+                                  g_object_ref (tearing_surface),
+                                  tearing_control_surface_destructor);
+
+  tearing_surface->destroy_handler_id =
+    g_signal_connect (tearing_surface->surface, "destroy",
+                      G_CALLBACK (on_surface_destroyed),
+                      tearing_surface);
+
+  g_object_set_qdata (G_OBJECT (surface),
+                      quark_tearing_surface_data,
+                      tearing_surface);
+}
+
+static const struct wp_tearing_control_manager_v1_interface
+tearing_control_manager_implementation = {
+  wp_tearing_control_manager_destroy,
+  wp_tearing_control_manager_get_tearing_control,
+};
+
+static void
+bind_tearing_controller (struct wl_client *client,
+                         void             *data,
+                         uint32_t          version,
+                         uint32_t          id)
+{
+  struct wl_resource *resource;
+
+  resource = wl_resource_create (client,
+                                 &wp_tearing_control_manager_v1_interface,
+                                 version, id);
+
+  wl_resource_set_implementation (resource,
+                                  &tearing_control_manager_implementation,
+                                  NULL, NULL);
+}
+
+void
+meta_wayland_tearing_controller_init (MetaWaylandCompositor *compositor)
+{
+  if (!wl_global_create (compositor->wayland_display,
+                         &wp_tearing_control_manager_v1_interface,
+                         META_WP_TEARING_CONTROL_V1_VERSION,
+                         NULL,
+                         bind_tearing_controller))
+    {
+      g_error ("Failed to register a global wp_tearing_control object");
+      return;
+    }
+
+  quark_tearing_surface_data =
+    g_quark_from_static_string ("-meta-wayland-tearing-surface-data");
+}
diff --git a/src/wayland/meta-wayland-tearing-control.h b/src/wayland/meta-wayland-tearing-control.h
new file mode 100644
index 0000000000..093b8f7d96
--- /dev/null
+++ b/src/wayland/meta-wayland-tearing-control.h
@@ -0,0 +1,39 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2025 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Naveen Kumar <naveen1.kumar@intel.com>
+ */
+
+/*
+ * MetaWaylandTearingControl
+ *
+ * Handles passing Tearing Control in Wayland
+ *
+ * The MetaWaylandTearingControl namespace adds core support for tearing
+ * control that are passed through from clients in Wayland (e.g. using
+ * the tearing_control_staging_v1 protocol).
+ */
+
+#pragma once
+
+#include <glib.h>
+
+#include "wayland/meta-wayland-types.h"
+
+void meta_wayland_tearing_controller_init (MetaWaylandCompositor *compositor);
diff --git a/src/wayland/meta-wayland-versions.h b/src/wayland/meta-wayland-versions.h
index e9cf9856c2..cac623c51b 100644
--- a/src/wayland/meta-wayland-versions.h
+++ b/src/wayland/meta-wayland-versions.h
@@ -70,3 +70,4 @@
 #define META_WP_COLOR_REPRESENTATION_VERSION 1
 #define META_WL_FIXES_VERSION 1
 #define META_WP_POINTER_WARP_VERSION 1
+#define META_WP_TEARING_CONTROL_V1_VERSION 1
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index f2f3775eed..cac547c93f 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -63,6 +63,7 @@
 #include "wayland/meta-wayland-subsurface.h"
 #include "wayland/meta-wayland-system-bell.h"
 #include "wayland/meta-wayland-tablet-manager.h"
+#include "wayland/meta-wayland-tearing-control.h"
 #include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-xdg-dialog.h"
 #include "wayland/meta-wayland-xdg-foreign.h"
@@ -1036,6 +1037,7 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_init_cursor_shape (compositor);
   meta_wayland_init_color_representation (compositor);
   meta_wayland_init_fixes (compositor);
+  meta_wayland_tearing_controller_init (compositor);
 
 #ifdef HAVE_WAYLAND_EGLSTREAM
   {
-- 
2.52.0


From a1c39b6c1feff6da10ac14c18f7b5bf49126d3aa Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Thu, 24 Oct 2024 12:06:15 +0000
Subject: [PATCH 5/8] kms/plane: Use g_autoptr & g_steal_pointer in
 update_formats

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-kms-plane.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/src/backends/native/meta-kms-plane.c b/src/backends/native/meta-kms-plane.c
index d8eef0a8bc..5a9be08f25 100644
--- a/src/backends/native/meta-kms-plane.c
+++ b/src/backends/native/meta-kms-plane.c
@@ -342,7 +342,7 @@ free_modifier_array (GArray *array)
   if (!array)
     return;
 
-  g_array_free (array, TRUE);
+  g_array_unref (array);
 }
 
 static void
@@ -391,7 +391,9 @@ update_formats (MetaKmsPlane      *plane,
 
   for (fmt_i = 0; fmt_i < blob_fmt->count_formats; fmt_i++)
     {
-      GArray *modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
+      g_autoptr (GArray) modifiers = NULL;
+
+      modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
 
       if (meta_is_topic_enabled (META_DEBUG_KMS))
         {
@@ -422,13 +424,13 @@ update_formats (MetaKmsPlane      *plane,
 
       if (modifiers->len == 0)
         {
-          free_modifier_array (modifiers);
+          g_clear_pointer (&modifiers, g_array_unref);
           modifiers = NULL;
         }
 
       g_hash_table_insert (plane->formats_modifiers,
                            GUINT_TO_POINTER (formats[fmt_i]),
-                           modifiers);
+                           g_steal_pointer (&modifiers));
     }
 
   drmModeFreePropertyBlob (blob);
-- 
2.52.0


From ae927aaaa1558a918fa0ee9b76a2c9180c8138f6 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Wed, 26 Feb 2025 13:51:19 +0000
Subject: [PATCH 6/8] backends/native: Add support for in_formats_async drm
 property

Introduce the new DRM property IN_FORMATS_ASYNC, allowing the
compositor to populate a list of formats and modifiers that
support tearing (async). This enables the use of appropriate
modifiers when tearing is enabled.

Kernel patchwork: https://patchwork.freedesktop.org/series/140935/

Changes in v2:
- Check for the availability of the IN_FORMATS_TEARING property.
- Utilize g_autoptr and g_steal_pointer for GArray in update_formats.
  (Sebastian Wick)

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 .../native/meta-kms-impl-device-atomic.c      |  5 +
 src/backends/native/meta-kms-plane-private.h  |  1 +
 src/backends/native/meta-kms-plane.c          | 99 +++++++++++++++++++
 src/backends/native/meta-kms-plane.h          |  3 +
 src/backends/native/meta-kms-types.h          |  1 +
 src/backends/native/meta-kms-update.c         | 16 +++
 src/backends/native/meta-kms-update.h         |  7 ++
 src/backends/native/meta-onscreen-native.c    | 73 ++++++++++----
 src/backends/native/meta-onscreen-native.h    |  5 +
 src/compositor/meta-compositor-native.c       |  6 +-
 src/compositor/meta-compositor-view-native.c  | 31 ++++++
 src/wayland/meta-wayland-dma-buf.c            | 45 +++++++--
 src/wayland/meta-wayland-surface-private.h    |  2 +
 src/wayland/meta-wayland-surface.c            |  6 ++
 14 files changed, 274 insertions(+), 26 deletions(-)

diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 7860cc2c6b..89aee54721 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -992,6 +992,8 @@ commit_flags_string (uint32_t commit_flags)
     commit_flag_strings[i++] = "PAGE_FLIP_EVENT";
   if (commit_flags & DRM_MODE_ATOMIC_TEST_ONLY)
     commit_flag_strings[i++] = "TEST_ONLY";
+  if (commit_flags & DRM_MODE_PAGE_FLIP_ASYNC)
+    commit_flag_strings[i++] = "PAGE_FLIP_ASYNC";
 
   commit_flags_string = g_strjoinv ("|", (char **) commit_flag_strings);
   strncpy (static_commit_flags_string, commit_flags_string,
@@ -1186,6 +1188,9 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
   if (flags & META_KMS_UPDATE_FLAG_TEST_ONLY)
     commit_flags |= DRM_MODE_ATOMIC_TEST_ONLY;
 
+  if (meta_kms_update_get_async (update))
+    commit_flags |= DRM_MODE_PAGE_FLIP_ASYNC;
+
   meta_topic (META_DEBUG_KMS,
               "[atomic] Committing update flags: %s",
               commit_flags_string (commit_flags));
diff --git a/src/backends/native/meta-kms-plane-private.h b/src/backends/native/meta-kms-plane-private.h
index c34488ec91..1e481473f0 100644
--- a/src/backends/native/meta-kms-plane-private.h
+++ b/src/backends/native/meta-kms-plane-private.h
@@ -28,6 +28,7 @@ typedef enum _MetaKmsPlaneProp
   META_KMS_PLANE_PROP_TYPE = 0,
   META_KMS_PLANE_PROP_ROTATION,
   META_KMS_PLANE_PROP_IN_FORMATS,
+  META_KMS_PLANE_PROP_IN_FORMATS_ASYNC,
   META_KMS_PLANE_PROP_SRC_X,
   META_KMS_PLANE_PROP_SRC_Y,
   META_KMS_PLANE_PROP_SRC_W,
diff --git a/src/backends/native/meta-kms-plane.c b/src/backends/native/meta-kms-plane.c
index 5a9be08f25..97c9ce340b 100644
--- a/src/backends/native/meta-kms-plane.c
+++ b/src/backends/native/meta-kms-plane.c
@@ -58,6 +58,8 @@ struct _MetaKmsPlane
    */
   GHashTable *formats_modifiers;
 
+  GHashTable *async_formats_modifiers;
+
   MetaKmsPlaneCursorSizeHints size_hints;
 
   MetaKmsPlanePropTable prop_table;
@@ -284,6 +286,14 @@ meta_kms_plane_get_modifiers_for_format (MetaKmsPlane *plane,
                               GUINT_TO_POINTER (format));
 }
 
+GArray *
+meta_kms_plane_get_async_modifiers_for_format (MetaKmsPlane *plane,
+                                               uint32_t      format)
+{
+  return g_hash_table_lookup (plane->async_formats_modifiers,
+                              GUINT_TO_POINTER (format));
+}
+
 GArray *
 meta_kms_plane_copy_drm_format_list (MetaKmsPlane *plane)
 {
@@ -436,6 +446,82 @@ update_formats (MetaKmsPlane      *plane,
   drmModeFreePropertyBlob (blob);
 }
 
+static void
+update_async_formats (MetaKmsPlane      *plane,
+                      MetaKmsImplDevice *impl_device)
+{
+  uint64_t blob_id;
+  int fd;
+  drmModePropertyBlobPtr blob;
+  struct drm_format_modifier_blob *blob_fmt;
+  uint32_t *async_formats;
+  struct drm_format_modifier *drm_modifiers;
+  unsigned int fmt_i, mod_i;
+  MetaKmsProp *in_formats_async;
+
+  g_return_if_fail (g_hash_table_size (plane->async_formats_modifiers) == 0);
+
+  in_formats_async = &plane->prop_table.props[META_KMS_PLANE_PROP_IN_FORMATS_ASYNC];
+  if (!in_formats_async->prop_id)
+    return;
+
+  blob_id = in_formats_async->value;
+  if (blob_id == 0)
+    return;
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+  blob = drmModeGetPropertyBlob (fd, blob_id);
+  if (!blob)
+    return;
+
+  if (blob->length < sizeof (struct drm_format_modifier_blob))
+    {
+      drmModeFreePropertyBlob (blob);
+      return;
+    }
+
+  blob_fmt = blob->data;
+
+  async_formats = drm_formats_ptr (blob_fmt);
+  drm_modifiers = drm_modifiers_ptr (blob_fmt);
+
+  for (fmt_i = 0; fmt_i < blob_fmt->count_formats; fmt_i++)
+    {
+      g_autoptr (GArray) modifiers = NULL;
+
+      modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
+
+      for (mod_i = 0; mod_i < blob_fmt->count_modifiers; mod_i++)
+        {
+          struct drm_format_modifier *drm_modifier = &drm_modifiers[mod_i];
+
+          /*
+           * The modifier advertisement blob is partitioned into groups of
+           * 64 formats.
+           */
+          if (fmt_i < drm_modifier->offset || fmt_i > drm_modifier->offset + 63)
+            continue;
+
+          if (!(drm_modifier->formats & (1 << (fmt_i - drm_modifier->offset))))
+            continue;
+
+          g_array_append_val (modifiers, drm_modifier->modifier);
+        }
+
+      if (modifiers->len == 0)
+        {
+          g_clear_pointer (&modifiers, g_array_unref);
+          modifiers = NULL;
+        }
+
+      g_hash_table_insert (plane->async_formats_modifiers,
+                           GUINT_TO_POINTER (async_formats[fmt_i]),
+                           g_steal_pointer (&modifiers));
+    }
+
+  drmModeFreePropertyBlob (blob);
+}
+
 static void
 update_cursor_size_hints (MetaKmsPlane      *plane,
                           MetaKmsImplDevice *impl_device)
@@ -556,6 +642,7 @@ meta_kms_plane_read_state (MetaKmsPlane            *plane,
                                           META_KMS_PLANE_N_PROPS);
 
   update_formats (plane, impl_device);
+  update_async_formats (plane, impl_device);
   update_cursor_size_hints (plane, impl_device);
   update_rotations (plane);
   update_legacy_formats (plane, drm_plane);
@@ -685,6 +772,11 @@ init_properties (MetaKmsPlane            *plane,
           .enum_values = prop_table->color_ranges,
           .num_enum_values = META_KMS_PLANE_YCBCR_COLOR_RANGE_N_PROPS,
           .default_value = META_KMS_PLANE_YCBCR_COLOR_RANGE_LIMITED,
+	},
+      [META_KMS_PLANE_PROP_IN_FORMATS_ASYNC] =
+        {
+          .name = "IN_FORMATS_ASYNC",
+          .type = DRM_MODE_PROP_BLOB,
         },
     },
     .rotation_bitmask = {
@@ -808,6 +900,7 @@ meta_kms_plane_finalize (GObject *object)
   MetaKmsPlane *plane = META_KMS_PLANE (object);
 
   g_hash_table_destroy (plane->formats_modifiers);
+  g_hash_table_destroy (plane->async_formats_modifiers);
   g_clear_pointer (&plane->size_hints.cursor_width, g_free);
   g_clear_pointer (&plane->size_hints.cursor_height, g_free);
 
@@ -822,6 +915,12 @@ meta_kms_plane_init (MetaKmsPlane *plane)
                            g_direct_equal,
                            NULL,
                            (GDestroyNotify) free_modifier_array);
+
+  plane->async_formats_modifiers =
+    g_hash_table_new_full (g_direct_hash,
+                           g_direct_equal,
+                           NULL,
+                           (GDestroyNotify) free_modifier_array);
 }
 
 static void
diff --git a/src/backends/native/meta-kms-plane.h b/src/backends/native/meta-kms-plane.h
index adcabfc8a1..fde33a4895 100644
--- a/src/backends/native/meta-kms-plane.h
+++ b/src/backends/native/meta-kms-plane.h
@@ -85,6 +85,9 @@ gboolean meta_kms_plane_supports_cursor_hotspot (MetaKmsPlane *plane);
 GArray * meta_kms_plane_get_modifiers_for_format (MetaKmsPlane *plane,
                                                   uint32_t      format);
 
+GArray * meta_kms_plane_get_async_modifiers_for_format (MetaKmsPlane *plane,
+                                                        uint32_t      format);
+
 GArray * meta_kms_plane_copy_drm_format_list (MetaKmsPlane *plane);
 
 gboolean meta_kms_plane_is_format_supported (MetaKmsPlane *plane,
diff --git a/src/backends/native/meta-kms-types.h b/src/backends/native/meta-kms-types.h
index 63530cf9d7..aa15887049 100644
--- a/src/backends/native/meta-kms-types.h
+++ b/src/backends/native/meta-kms-types.h
@@ -81,6 +81,7 @@ typedef enum _MetaKmsUpdateFlag
   META_KMS_UPDATE_FLAG_NONE = 0,
   META_KMS_UPDATE_FLAG_TEST_ONLY = 1 << 0,
   META_KMS_UPDATE_FLAG_MODE_SET = 1 << 1,
+  META_KMS_UPDATE_FLAG_PAGE_FLIP_ASYNC = 1 << 2,
 } MetaKmsUpdateFlag;
 
 typedef enum _MetaKmsPlaneType MetaKmsPlaneType;
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index d37061ded1..1da48ffb36 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -52,6 +52,8 @@ struct _MetaKmsUpdate
 
   gboolean needs_modeset;
 
+  gboolean async_enabled;
+
   MetaKmsImplDevice *impl_device;
 
   int sync_fd;
@@ -1160,6 +1162,7 @@ meta_kms_update_merge_from (MetaKmsUpdate *update,
   merge_result_listeners_from (update, other_update);
 
   meta_kms_update_set_sync_fd (update, g_steal_fd (&other_update->sync_fd));
+  meta_kms_update_set_async (update, other_update->async_enabled);
 }
 
 gboolean
@@ -1243,6 +1246,19 @@ meta_kms_update_set_sync_fd (MetaKmsUpdate *update,
   update->sync_fd = sync_fd;
 }
 
+gboolean
+meta_kms_update_get_async (MetaKmsUpdate *update)
+{
+  return update->async_enabled;
+}
+
+void
+meta_kms_update_set_async (MetaKmsUpdate *update,
+                           gboolean       async_enabled)
+{
+  update->async_enabled = async_enabled;
+}
+
 gboolean
 meta_kms_update_is_empty (MetaKmsUpdate *update)
 {
diff --git a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
index cf08245af9..2cb3f67fd3 100644
--- a/src/backends/native/meta-kms-update.h
+++ b/src/backends/native/meta-kms-update.h
@@ -164,6 +164,13 @@ void
 meta_kms_update_set_sync_fd (MetaKmsUpdate *update,
                              int            sync_fd);
 
+gboolean
+meta_kms_update_get_async (MetaKmsUpdate *update);
+
+void
+meta_kms_update_set_async (MetaKmsUpdate *update,
+                           gboolean       enabled);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const MtkRegion        *region);
 
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 5f76e23ca9..6eb8ca1b77 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -128,6 +128,8 @@ struct _MetaOnscreenNative
 
   gboolean is_tearing_allowed;
 
+  gboolean tearing_enabled;
+
   MetaRendererView *view;
 
   union {
@@ -275,10 +277,17 @@ page_flip_feedback_flipped (MetaKmsCrtc  *kms_crtc,
                             gpointer      user_data)
 {
   MetaRendererView *view = user_data;
+  CoglFramebuffer *framebuffer =
+    clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
+  CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   struct timeval page_flip_time;
   MetaKmsDevice *kms_device;
   int64_t presentation_time_us;
-  CoglFrameInfoFlag flags = COGL_FRAME_INFO_FLAG_VSYNC;
+  CoglFrameInfoFlag flags = COGL_FRAME_INFO_FLAG_NONE;
+
+  if (!meta_onscreen_native_is_tearing_enabled (onscreen_native))
+    flags |= COGL_FRAME_INFO_FLAG_VSYNC;
 
   page_flip_time = (struct timeval) {
     .tv_sec = tv_sec,
@@ -1757,6 +1766,9 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
   if (sync_fd >= 0)
     meta_kms_update_set_sync_fd (kms_update, g_steal_fd (&sync_fd));
 
+  meta_kms_update_set_async (kms_update,
+                             onscreen_native->tearing_enabled);
+
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
 }
@@ -1787,6 +1799,9 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
   cogl_scanout_get_src_rect (scanout, &src_rect);
   cogl_scanout_get_dst_rect (scanout, &dst_rect);
 
+  meta_kms_update_set_async (test_update,
+                             onscreen_native->tearing_enabled);
+
   buffer = META_DRM_BUFFER (cogl_scanout_get_buffer (scanout));
   assign_primary_plane (crtc_kms,
                         buffer,
@@ -1938,15 +1953,34 @@ meta_onscreen_native_request_frame_sync (MetaOnscreenNative *onscreen_native,
   onscreen_native->frame_sync_requested = enabled;
 }
 
+void
+meta_onscreen_native_request_tearing (MetaOnscreenNative *onscreen_native,
+                                      gboolean            tearing_requested)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+
+  if (onscreen_native->is_tearing_allowed &&
+      meta_kms_device_supports_async_page_flip (kms_device))
+    onscreen_native->tearing_enabled = tearing_requested;
+}
+
 gboolean
 meta_onscreen_native_is_frame_sync_enabled (MetaOnscreenNative *onscreen_native)
 {
   return onscreen_native->frame_sync_enabled;
 }
 
+gboolean
+meta_onscreen_native_is_tearing_enabled (MetaOnscreenNative *onscreen_native)
+{
+  return onscreen_native->tearing_enabled;
+}
+
 static void
-maybe_update_frame_sync (MetaOnscreenNative *onscreen_native,
-                         ClutterFrame       *frame)
+maybe_update_frame_sync_or_tearing (MetaOnscreenNative *onscreen_native,
+                                    ClutterFrame       *frame)
 {
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
   MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
@@ -1961,23 +1995,28 @@ maybe_update_frame_sync (MetaOnscreenNative *onscreen_native,
   MetaKmsUpdate *kms_update;
   gboolean frame_sync_enabled = FALSE;
 
-  if (meta_output_is_vrr_enabled (onscreen_native->output))
-    frame_sync_enabled = onscreen_native->frame_sync_requested;
+  kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
 
-  if (frame_sync_enabled != onscreen_native->frame_sync_enabled)
+  if (meta_output_is_vrr_enabled (onscreen_native->output))
     {
-      frame_clock_mode = frame_sync_enabled ? CLUTTER_FRAME_CLOCK_MODE_VARIABLE :
-                                              CLUTTER_FRAME_CLOCK_MODE_FIXED;
-      clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
-      onscreen_native->frame_sync_enabled = frame_sync_enabled;
-    }
+      frame_sync_enabled = onscreen_native->frame_sync_requested;
 
-  if (crtc_state->vrr.supported &&
-      frame_sync_enabled != crtc_state->vrr.enabled)
-    {
-      kms_update = meta_frame_native_ensure_kms_update (frame_native, kms_device);
-      meta_kms_update_set_vrr (kms_update, kms_crtc, frame_sync_enabled);
+      if (frame_sync_enabled != onscreen_native->frame_sync_enabled)
+        onscreen_native->frame_sync_enabled = frame_sync_enabled;
+
+      if (crtc_state->vrr.supported &&
+          frame_sync_enabled != crtc_state->vrr.enabled)
+        {
+          meta_kms_update_set_vrr (kms_update, kms_crtc, frame_sync_enabled);
+        }
     }
+
+  if (onscreen_native->frame_sync_enabled || onscreen_native->tearing_enabled)
+    frame_clock_mode = CLUTTER_FRAME_CLOCK_MODE_VARIABLE;
+  else
+    frame_clock_mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
+  clutter_frame_clock_set_mode (frame_clock, frame_clock_mode);
+
 }
 
 void
@@ -1994,7 +2033,7 @@ meta_onscreen_native_before_redraw (CoglOnscreen *onscreen,
       meta_kms_device_await_flush (meta_kms_crtc_get_device (kms_crtc), kms_crtc);
     }
 
-  maybe_update_frame_sync (onscreen_native, frame);
+  maybe_update_frame_sync_or_tearing (onscreen_native, frame);
 }
 
 void
diff --git a/src/backends/native/meta-onscreen-native.h b/src/backends/native/meta-onscreen-native.h
index e30357d19d..b4244513e0 100644
--- a/src/backends/native/meta-onscreen-native.h
+++ b/src/backends/native/meta-onscreen-native.h
@@ -72,3 +72,8 @@ void meta_onscreen_native_request_frame_sync (MetaOnscreenNative *onscreen_nativ
                                               gboolean            enabled);
 
 gboolean meta_onscreen_native_is_frame_sync_enabled (MetaOnscreenNative *onscreen_native);
+
+void meta_onscreen_native_request_tearing (MetaOnscreenNative *onscreen_native,
+                                           gboolean            enabled);
+
+gboolean meta_onscreen_native_is_tearing_enabled (MetaOnscreenNative *onscreen_native);
diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index 06841bbd35..3d52e36ccf 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -39,14 +39,14 @@ meta_compositor_native_before_paint (MetaCompositor     *compositor,
     META_COMPOSITOR_VIEW_NATIVE (compositor_view);
   MetaCompositorClass *parent_class;
 
+  meta_compositor_view_native_maybe_update_frame_sync_surface (compositor_view_native,
+                                                               compositor);
+
 #ifdef HAVE_WAYLAND
   meta_compositor_view_native_maybe_assign_scanout (compositor_view_native,
                                                     compositor);
 #endif
 
-  meta_compositor_view_native_maybe_update_frame_sync_surface (compositor_view_native,
-                                                               compositor);
-
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
   parent_class->before_paint (compositor, compositor_view, frame);
 }
diff --git a/src/compositor/meta-compositor-view-native.c b/src/compositor/meta-compositor-view-native.c
index e683b09051..4944575d60 100644
--- a/src/compositor/meta-compositor-view-native.c
+++ b/src/compositor/meta-compositor-view-native.c
@@ -106,15 +106,29 @@ on_frame_sync_surface_is_frozen_changed (MetaSurfaceActor         *surface_actor
                                          GParamSpec               *pspec,
                                          MetaCompositorViewNative *view_native)
 {
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  CoglFramebuffer *framebuffer = clutter_stage_view_get_onscreen (stage_view);
+
   if (meta_surface_actor_is_frozen (surface_actor))
     update_frame_sync_surface (view_native, NULL);
+
+  meta_onscreen_native_request_tearing (META_ONSCREEN_NATIVE (framebuffer),
+                                        FALSE);
 }
 
 static void
 on_frame_sync_surface_destroyed (MetaSurfaceActor         *surface_actor,
                                  MetaCompositorViewNative *view_native)
 {
+  MetaCompositorView *compositor_view = META_COMPOSITOR_VIEW (view_native);
+  ClutterStageView *stage_view = meta_compositor_view_get_stage_view (compositor_view);
+  CoglFramebuffer *framebuffer = clutter_stage_view_get_onscreen (stage_view);
+
   update_frame_sync_surface (view_native, NULL);
+
+  meta_onscreen_native_request_tearing (META_ONSCREEN_NATIVE (framebuffer),
+                                        FALSE);
 }
 
 #ifdef HAVE_WAYLAND
@@ -508,6 +522,9 @@ update_frame_sync_surface (MetaCompositorViewNative *view_native,
     META_COMPOSITOR_VIEW (view_native);
   ClutterStageView *stage_view;
   CoglFramebuffer *framebuffer;
+  MetaSurfaceActorWayland *surface_actor_wayland;
+  MetaWaylandSurface *surface;
+  gboolean tearing_enabled;
 
   g_clear_signal_handler (&view_native->frame_sync_surface_repaint_scheduled_id,
                           view_native->frame_sync_surface);
@@ -549,6 +566,20 @@ update_frame_sync_surface (MetaCompositorViewNative *view_native,
 
   meta_onscreen_native_request_frame_sync (META_ONSCREEN_NATIVE (framebuffer),
                                            surface_actor != NULL);
+
+  if (!surface_actor)
+    return;
+
+  surface_actor_wayland = META_SURFACE_ACTOR_WAYLAND (surface_actor);
+  surface = meta_surface_actor_wayland_get_surface (surface_actor_wayland);
+  if (!surface)
+    return;
+
+  tearing_enabled = meta_wayland_surface_get_is_tearing_enabled (surface);
+  if (tearing_enabled !=
+      meta_onscreen_native_is_tearing_enabled (META_ONSCREEN_NATIVE (framebuffer)))
+    meta_onscreen_native_request_tearing (META_ONSCREEN_NATIVE (framebuffer),
+                                          tearing_enabled);
 }
 
 void
diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 13c6f9d409..7fd4616915 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -621,10 +621,20 @@ has_modifier (GArray   *modifiers,
 }
 
 #ifdef HAVE_NATIVE_BACKEND
+static gboolean
+async_supports_modifier (MetaKmsPlane *plane,
+                         uint32_t      drm_format,
+                         uint64_t      drm_modifier)
+{
+  GArray *async_modifiers = meta_kms_plane_get_async_modifiers_for_format (plane, drm_format);
+  return async_modifiers && has_modifier (async_modifiers, drm_modifier);
+}
+
 static gboolean
 crtc_supports_modifier (MetaCrtcKms *crtc_kms,
                         uint32_t     drm_format,
-                        uint64_t     drm_modifier)
+                        uint64_t     drm_modifier,
+                        gboolean     is_async)
 {
   MetaKmsPlane *plane = meta_crtc_kms_get_assigned_primary_plane (crtc_kms);
   GArray *crtc_modifiers;
@@ -641,7 +651,15 @@ crtc_supports_modifier (MetaCrtcKms *crtc_kms,
   if (!crtc_modifiers)
     return FALSE;
 
-  return has_modifier (crtc_modifiers, drm_modifier);
+  if (!has_modifier (crtc_modifiers, drm_modifier))
+    return FALSE;
+
+  /* Bi-sect: GL, CRTC & Async common supported modifiers */
+  if (is_async &&
+      !async_supports_modifier (plane, drm_format, drm_modifier))
+    return FALSE;
+
+  return TRUE;
 }
 #endif
 
@@ -671,6 +689,7 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandBuffer     *buffer,
   const MetaFormatInfo *format_info;
   uint32_t drm_format;
   gboolean use_modifier;
+  gboolean is_async;
   int n_planes;
 
   dma_buf = meta_wayland_dma_buf_from_buffer (buffer);
@@ -684,16 +703,19 @@ meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandBuffer     *buffer,
   format_info = meta_format_info_from_drm_format (dma_buf->drm_format);
   g_assert (format_info);
 
+  is_async = meta_onscreen_native_is_tearing_enabled (META_ONSCREEN_NATIVE (onscreen));
   if (format_info->opaque_substitute != DRM_FORMAT_INVALID &&
       crtc_supports_modifier (crtc_kms,
                               format_info->opaque_substitute,
-                              dma_buf->drm_modifier))
+                              dma_buf->drm_modifier,
+                              is_async))
     {
       drm_format = format_info->opaque_substitute;
     }
   else if (crtc_supports_modifier (crtc_kms,
                                    dma_buf->drm_format,
-                                   dma_buf->drm_modifier))
+                                   dma_buf->drm_modifier,
+                                   is_async))
     {
       drm_format = dma_buf->drm_format;
     }
@@ -1384,6 +1406,12 @@ ensure_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback,
   MetaContext *context =
     meta_wayland_compositor_get_context (dma_buf_manager->compositor);
   MetaBackend *backend = meta_context_get_backend (context);
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaRendererView *renderer_view = meta_renderer_get_view_for_crtc (renderer, crtc);
+  ClutterStageView *stage_view = CLUTTER_STAGE_VIEW (renderer_view);
+  CoglFramebuffer *framebuffer =
+    clutter_stage_view_get_onscreen (stage_view);
+  CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
   MetaWaylandDmaBufFeedback *feedback = surface_feedback->feedback;
   MetaCrtcKms *crtc_kms;
   MetaKmsPlane *kms_plane;
@@ -1416,6 +1444,9 @@ ensure_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback,
   formats = g_array_new (FALSE, FALSE, sizeof (MetaWaylandDmaBufFormat));
   if (should_send_modifiers_scanout_tranches (backend))
     {
+      gboolean is_async =
+        meta_onscreen_native_is_tearing_enabled (META_ONSCREEN_NATIVE (onscreen));
+
       for (i = 0; i < dma_buf_manager->formats->len; i++)
         {
           MetaWaylandDmaBufFormat format =
@@ -1428,7 +1459,8 @@ ensure_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback,
 
           if (!crtc_supports_modifier (crtc_kms,
                                        format.drm_format,
-                                       format.drm_modifier))
+                                       format.drm_modifier,
+                                       is_async))
             {
               const MetaFormatInfo *format_info;
 
@@ -1438,7 +1470,8 @@ ensure_scanout_tranche (MetaWaylandDmaBufSurfaceFeedback *surface_feedback,
               if (format_info->opaque_substitute == DRM_FORMAT_INVALID ||
                   !crtc_supports_modifier (crtc_kms,
                                            format_info->opaque_substitute,
-                                           format.drm_modifier))
+                                           format.drm_modifier,
+                                           is_async))
                 continue;
             }
 
diff --git a/src/wayland/meta-wayland-surface-private.h b/src/wayland/meta-wayland-surface-private.h
index 19ae72f59d..5182ae5012 100644
--- a/src/wayland/meta-wayland-surface-private.h
+++ b/src/wayland/meta-wayland-surface-private.h
@@ -431,6 +431,8 @@ CoglScanout *       meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface
 
 MetaCrtc * meta_wayland_surface_get_scanout_candidate (MetaWaylandSurface *surface);
 
+gboolean meta_wayland_surface_get_is_tearing_enabled (MetaWaylandSurface *surface);
+
 void meta_wayland_surface_set_scanout_candidate (MetaWaylandSurface *surface,
                                                  MetaCrtc           *crtc);
 
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index aeddd4de77..058776ff13 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -2342,6 +2342,12 @@ meta_wayland_surface_role_is_on_logical_monitor (MetaWaylandSurfaceRole *surface
     return FALSE;
 }
 
+gboolean
+meta_wayland_surface_get_is_tearing_enabled (MetaWaylandSurface *surface)
+{
+  return surface->applied_state.allow_tearing;
+}
+
 static MetaWaylandSurface *
 meta_wayland_surface_role_get_toplevel (MetaWaylandSurfaceRole *surface_role)
 {
-- 
2.52.0


From 0cc209f3971ab2a1ef5ec204b2eebc84d0e6d776 Mon Sep 17 00:00:00 2001
From: Naveen Kumar <naveen1.kumar@intel.com>
Date: Sun, 17 Aug 2025 12:19:30 +0000
Subject: [PATCH 7/8] backend: Disable hw cursor during async page flips

On some hardware (e.g. Intel), async commits are not supported on the
KMS cursor plane. As a result, async flips fail whenever the hardware
cursor is moved.

To ensure async page flips work reliably, disable the hardware cursor
and fall back to a software cursor while async mode is active.

This allows users to benefit from higher FPS with async page flips,
while the software cursor lag remains minimal or unnoticeable.

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/backends/native/meta-onscreen-native.c   | 12 ++++++++++-
 src/compositor/meta-compositor-view-native.c | 21 +++++++++++---------
 2 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 6eb8ca1b77..6c094b0091 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -1960,10 +1960,20 @@ meta_onscreen_native_request_tearing (MetaOnscreenNative *onscreen_native,
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
   MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
   MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  MetaRenderer *renderer =
+    META_RENDERER (onscreen_native->renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
 
   if (onscreen_native->is_tearing_allowed &&
       meta_kms_device_supports_async_page_flip (kms_device))
-    onscreen_native->tearing_enabled = tearing_requested;
+    {
+      onscreen_native->tearing_enabled = tearing_requested;
+
+      if (tearing_requested)
+        meta_backend_inhibit_hw_cursor (backend);
+      else
+        meta_backend_uninhibit_hw_cursor (backend);
+    }
 }
 
 gboolean
diff --git a/src/compositor/meta-compositor-view-native.c b/src/compositor/meta-compositor-view-native.c
index 4944575d60..4ab1407719 100644
--- a/src/compositor/meta-compositor-view-native.c
+++ b/src/compositor/meta-compositor-view-native.c
@@ -189,6 +189,14 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
 
   clutter_stage_view_get_layout (stage_view, &view_rect);
 
+  framebuffer = clutter_stage_view_get_onscreen (stage_view);
+  if (!COGL_IS_ONSCREEN (framebuffer))
+    {
+      meta_topic (META_DEBUG_RENDER,
+                  "No direct scanout candidate: no onscreen framebuffer");
+      return FALSE;
+    }
+
   cursor_sprite = meta_cursor_tracker_get_sprite (cursor_tracker);
   if (cursor_sprite &&
       meta_cursor_tracker_get_pointer_visible (cursor_tracker) &&
@@ -200,7 +208,10 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
       float scale;
       int hotspot_x;
       int hotspot_y;
+      gboolean is_tearing;
 
+      is_tearing =
+        meta_onscreen_native_is_tearing_enabled (META_ONSCREEN_NATIVE (framebuffer));
       meta_cursor_tracker_get_pointer (cursor_tracker, &position, NULL);
       meta_cursor_tracker_get_hot (cursor_tracker, &hotspot_x, &hotspot_y);
 
@@ -216,7 +227,7 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
       graphene_view_rect = mtk_rectangle_to_graphene_rect (&view_rect);
       if (graphene_rect_intersection (&graphene_view_rect,
                                       &cursor_rect,
-                                      NULL))
+                                      NULL) && !is_tearing)
         {
           meta_topic (META_DEBUG_RENDER,
                       "No direct scanout candidate: using software cursor");
@@ -232,14 +243,6 @@ find_scanout_candidate (MetaCompositorView  *compositor_view,
       return FALSE;
     }
 
-  framebuffer = clutter_stage_view_get_onscreen (stage_view);
-  if (!COGL_IS_ONSCREEN (framebuffer))
-    {
-      meta_topic (META_DEBUG_RENDER,
-                  "No direct scanout candidate: no onscreen framebuffer");
-      return FALSE;
-    }
-
   if (clutter_stage_view_has_shadowfb (stage_view))
     {
       meta_topic (META_DEBUG_RENDER,
-- 
2.52.0


From 843c11c2dcd9cb082ce7bf07809bb8414204df85 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timotej=20=C5=A0ul=C3=ADk?= <timotej.sulik@gmail.com>
Date: Sun, 1 Feb 2026 23:36:17 +0300
Subject: [PATCH 8/8] Fix tearing crash

Signed-off-by: Vasiliy Stelmachenok <ventureo@cachyos.org>
---
 src/wayland/meta-wayland-tearing-control.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-tearing-control.c b/src/wayland/meta-wayland-tearing-control.c
index dc0237c210..9a7461bc88 100644
--- a/src/wayland/meta-wayland-tearing-control.c
+++ b/src/wayland/meta-wayland-tearing-control.c
@@ -126,7 +126,11 @@ static void
 on_surface_destroyed (MetaWaylandSurface        *surface,
                       MetaWaylandTearingSurface *tearing_surface)
 {
-  clear_tearing_surface_data (tearing_surface);
+  /* The surface is being destroyed. Don't access it at all - not even
+   * to disconnect signals. Just clear our pointer. The signal will be
+   * automatically disconnected when the surface is finalized. */
+  tearing_surface->destroy_handler_id = 0;
+  tearing_surface->surface = NULL;
 }
 
 static void
-- 
2.52.0

