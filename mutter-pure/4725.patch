From e9f2b177e3e241474796179f7c7bdd96b2a7ca0e Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 2 Oct 2025 16:47:43 +0800
Subject: [PATCH 1/8] backends: Add function meta_egl_create_sync_fd

---
 src/backends/meta-egl.c | 27 +++++++++++++++++++++++++++
 src/backends/meta-egl.h |  4 ++++
 2 files changed, 31 insertions(+)

diff --git a/src/backends/meta-egl.c b/src/backends/meta-egl.c
index 50da9c46462..2ff9104a2b4 100644
--- a/src/backends/meta-egl.c
+++ b/src/backends/meta-egl.c
@@ -47,6 +47,7 @@ struct _MetaEgl
   PFNEGLCREATESYNCPROC eglCreateSync;
   PFNEGLDESTROYSYNCPROC eglDestroySync;
   PFNEGLWAITSYNCPROC eglWaitSync;
+  PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
 
   PFNEGLBINDWAYLANDDISPLAYWL eglBindWaylandDisplayWL;
   PFNEGLQUERYWAYLANDBUFFERWL eglQueryWaylandBufferWL;
@@ -1229,6 +1230,31 @@ meta_egl_wait_sync (MetaEgl     *egl,
   return TRUE;
 }
 
+int
+meta_egl_create_sync_fd (MetaEgl     *egl,
+                         EGLDisplay   display,
+                         GError     **error)
+{
+  EGLSync sync;
+  int sync_fd;
+
+  if (!is_egl_proc_valid (egl->eglDupNativeFenceFDANDROID, error))
+    return -1;
+
+  if (!meta_egl_create_sync (egl, display, EGL_SYNC_NATIVE_FENCE_ANDROID,
+                             NULL, &sync, error))
+    return -1;
+
+  sync_fd = egl->eglDupNativeFenceFDANDROID (display, sync);
+  if (sync_fd < 0)
+    set_egl_error (error);
+
+  if (!meta_egl_destroy_sync (egl, display, sync, NULL))
+    g_warn_if_reached ();
+
+  return sync_fd;
+}
+
 #define GET_EGL_PROC_ADDR(proc) \
   egl->proc = (void *) eglGetProcAddress (#proc);
 
@@ -1245,6 +1271,7 @@ meta_egl_constructed (GObject *object)
   GET_EGL_PROC_ADDR (eglCreateSync);
   GET_EGL_PROC_ADDR (eglDestroySync);
   GET_EGL_PROC_ADDR (eglWaitSync);
+  GET_EGL_PROC_ADDR (eglDupNativeFenceFDANDROID);
 
   GET_EGL_PROC_ADDR (eglBindWaylandDisplayWL);
   GET_EGL_PROC_ADDR (eglQueryWaylandBufferWL);
diff --git a/src/backends/meta-egl.h b/src/backends/meta-egl.h
index af3150c3c94..f6d176ba18d 100644
--- a/src/backends/meta-egl.h
+++ b/src/backends/meta-egl.h
@@ -294,3 +294,7 @@ gboolean meta_egl_wait_sync (MetaEgl     *egl,
                              EGLSync      sync,
                              EGLint       flags,
                              GError     **error);
+
+int meta_egl_create_sync_fd (MetaEgl     *egl,
+                             EGLDisplay   display,
+                             GError     **error);
-- 
GitLab


From 2d973dcc4e763bc823f8b404949588f862e784a2 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 2 Oct 2025 16:28:22 +0800
Subject: [PATCH 2/8] onscreen/native: Get sync_fd from the secondary GPU if
 necessary

---
 src/backends/native/meta-onscreen-native.c | 40 ++++++++++++++--------
 1 file changed, 26 insertions(+), 14 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index d91cd6b6dc0..2ea42669dd1 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -918,6 +918,7 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
 
 static MetaDrmBuffer *
 copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                             MetaFrameNative                      *frame_native,
                              MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
                              MetaRendererNativeGpuData            *renderer_gpu_data,
                              MetaDrmBuffer                        *primary_gpu_fb,
@@ -937,14 +938,14 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   MetaDrmBufferGbm *buffer_gbm = NULL;
   struct gbm_bo *bo;
   EGLSync egl_sync = EGL_NO_SYNC;
-  g_autofd int sync_fd = -1;
+  g_autofd int sync_fd = meta_frame_native_steal_sync_fd (frame_native);
   EGLImageKHR egl_image;
 
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "copy_shared_framebuffer_gpu()");
 
-  if (renderer_gpu_data->secondary.needs_explicit_sync)
-    sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+  if (!renderer_gpu_data->secondary.needs_explicit_sync)
+    g_clear_fd (&sync_fd, NULL);
 
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
@@ -1021,6 +1022,16 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
       goto done;
     }
 
+  g_warn_if_fail (sync_fd == -1);
+  sync_fd = meta_egl_create_sync_fd (egl, egl_display, error);
+  if (sync_fd < 0)
+    {
+      g_prefix_error (error, "Failed to create sync fd: ");
+      goto done;
+    }
+
+  meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+
   use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
   device_file = meta_render_device_get_device_file (render_device);
 
@@ -1327,10 +1338,11 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen    *onscreen,
 }
 
 static MetaDrmBuffer *
-acquire_front_buffer (CoglOnscreen   *onscreen,
-                      MetaDrmBuffer  *primary_gpu_fb,
-                      MetaDrmBuffer  *secondary_gpu_fb,
-                      GError        **error)
+acquire_front_buffer (CoglOnscreen     *onscreen,
+                      MetaFrameNative  *frame_native,
+                      MetaDrmBuffer    *primary_gpu_fb,
+                      MetaDrmBuffer    *secondary_gpu_fb,
+                      GError          **error)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
@@ -1372,6 +1384,7 @@ acquire_front_buffer (CoglOnscreen   *onscreen,
       return g_object_ref (secondary_gpu_fb);
     case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
       return copy_shared_framebuffer_gpu (onscreen,
+                                          frame_native,
                                           secondary_gpu_state,
                                           renderer_gpu_data,
                                           primary_gpu_fb,
@@ -1492,6 +1505,7 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) buffer = NULL;
+  g_autofd int sync_fd = -1;
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
                            "Meta::OnscreenNative::swap_buffers_with_damage()");
@@ -1521,6 +1535,10 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                           frame_info,
                                           user_data);
 
+  sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+  if (sync_fd >= 0)
+    meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
   render_device_file =
@@ -1547,6 +1565,7 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
       primary_gpu_fb = META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
       buffer = acquire_front_buffer (onscreen,
+                                     frame_native,
                                      primary_gpu_fb,
                                      secondary_gpu_fb,
                                      &error);
@@ -1581,13 +1600,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
   meta_frame_native_set_damage (frame_native, region);
 
-  if (!secondary_gpu_used)
-    {
-      int sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
-
-      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
-    }
-
   maybe_post_next_frame (onscreen);
   return;
 
-- 
GitLab


From c47da0f689ad2433f9cc22218c1ce09690713796 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 25 Sep 2025 16:30:56 +0800
Subject: [PATCH 3/8] onscreen/native: Don't commit to acquiring the primary
 GPU FB late

Because we'll soon want to acquire it early for COPY_MODE_SECONDARY_GPU
---
 src/backends/native/meta-onscreen-native.c | 83 +++++++++++++---------
 1 file changed, 50 insertions(+), 33 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 2ea42669dd1..e85bfec4a44 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -879,15 +879,51 @@ secondary_gpu_state_free (MetaOnscreenNativeSecondaryGpuState *secondary_gpu_sta
   g_free (secondary_gpu_state);
 }
 
+static MetaDrmBuffer *
+acquire_primary_front_buffer (CoglOnscreen  *onscreen,
+                              GError       **error)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  MetaRendererNative *renderer_native = onscreen_native->renderer_native;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer_get_winsys (cogl_renderer);
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaDrmBufferFlags buffer_flags;
+  MetaDrmBufferGbm *buffer_gbm;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+  MetaDeviceFile *render_device_file =
+    meta_render_device_get_device_file (render_device);
+
+  buffer_flags = META_DRM_BUFFER_FLAG_NONE;
+  if (!meta_renderer_native_use_modifiers (renderer_native))
+    buffer_flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+
+  buffer_gbm =
+    meta_drm_buffer_gbm_new_lock_front (render_device_file,
+                                        onscreen_native->gbm.surface,
+                                        buffer_flags,
+                                        error);
+  if (!buffer_gbm)
+    return NULL;
+
+  return META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
+}
+
 static MetaDrmBuffer *
 import_shared_framebuffer (CoglOnscreen                        *onscreen,
-                           MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state,
-                           MetaDrmBuffer                       *primary_gpu_fb)
+                           MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
 {
   MetaRenderDevice *render_device;
   g_autoptr (GError) error = NULL;
+  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   MetaDrmBuffer *imported_buffer;
 
+  primary_gpu_fb = acquire_primary_front_buffer (onscreen, &error);
+  if (!primary_gpu_fb)
+    return NULL;
+
   render_device = secondary_gpu_state->renderer_gpu_data->render_device;
   imported_buffer =
     meta_render_device_import_dma_buf (render_device,
@@ -921,7 +957,6 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
                              MetaFrameNative                      *frame_native,
                              MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
                              MetaRendererNativeGpuData            *renderer_gpu_data,
-                             MetaDrmBuffer                        *primary_gpu_fb,
                              GError                              **error)
 {
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
@@ -940,10 +975,15 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   EGLSync egl_sync = EGL_NO_SYNC;
   g_autofd int sync_fd = meta_frame_native_steal_sync_fd (frame_native);
   EGLImageKHR egl_image;
+  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
 
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "copy_shared_framebuffer_gpu()");
 
+  primary_gpu_fb = acquire_primary_front_buffer (onscreen, error);
+  if (!primary_gpu_fb)
+    return NULL;
+
   if (!renderer_gpu_data->secondary.needs_explicit_sync)
     g_clear_fd (&sync_fd, NULL);
 
@@ -1340,7 +1380,6 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen    *onscreen,
 static MetaDrmBuffer *
 acquire_front_buffer (CoglOnscreen     *onscreen,
                       MetaFrameNative  *frame_native,
-                      MetaDrmBuffer    *primary_gpu_fb,
                       MetaDrmBuffer    *secondary_gpu_fb,
                       GError          **error)
 {
@@ -1355,7 +1394,7 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
 
   secondary_gpu_state = onscreen_native->secondary_gpu_state;
   if (!secondary_gpu_state)
-    return g_object_ref (primary_gpu_fb);
+    return acquire_primary_front_buffer (onscreen, error);
 
   renderer_gpu_data =
     meta_renderer_native_get_gpu_data (renderer_native,
@@ -1364,8 +1403,7 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
     {
     case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
       imported_fb = import_shared_framebuffer (onscreen,
-                                               secondary_gpu_state,
-                                               primary_gpu_fb);
+                                               secondary_gpu_state);
       if (imported_fb)
         return imported_fb;
       /* The fallback was prepared in pre_swap_buffers and is currently
@@ -1387,7 +1425,6 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
                                           frame_native,
                                           secondary_gpu_state,
                                           renderer_gpu_data,
-                                          primary_gpu_fb,
                                           error);
     }
 
@@ -1494,15 +1531,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
-  MetaDeviceFile *render_device_file;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   CoglOnscreenClass *parent_class;
   gboolean secondary_gpu_used = FALSE;
   g_autoptr (GError) error = NULL;
-  MetaDrmBufferFlags buffer_flags;
-  MetaDrmBufferGbm *buffer_gbm;
-  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) buffer = NULL;
   g_autofd int sync_fd = -1;
@@ -1541,32 +1574,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
-  render_device_file =
-    meta_render_device_get_device_file (renderer_gpu_data->render_device);
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
-      buffer_flags = META_DRM_BUFFER_FLAG_NONE;
-      if (!meta_renderer_native_use_modifiers (renderer_native))
-        buffer_flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
-
-      buffer_gbm =
-        meta_drm_buffer_gbm_new_lock_front (render_device_file,
-                                            onscreen_native->gbm.surface,
-                                            buffer_flags,
-                                            &error);
-      if (!buffer_gbm)
-        {
-          g_warning ("Failed to lock front buffer on %s: %s",
-                     meta_device_file_get_path (render_device_file),
-                     error->message);
-          goto swap_failed;
-        }
-
-      primary_gpu_fb = META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
       buffer = acquire_front_buffer (onscreen,
                                      frame_native,
-                                     primary_gpu_fb,
                                      secondary_gpu_fb,
                                      &error);
       if (buffer == NULL)
@@ -1579,6 +1591,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
       if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
         {
+          MetaRenderDevice *render_device =
+            renderer_gpu_data->render_device;
+          MetaDeviceFile *render_device_file =
+            meta_render_device_get_device_file (render_device);
+
           g_warning ("Failed to ensure KMS FB ID on %s: %s",
                      meta_device_file_get_path (render_device_file),
                      error->message);
-- 
GitLab


From bc660301204e5ada7472151adebfaca2e5f3f4a1 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 2 Oct 2025 17:28:42 +0800
Subject: [PATCH 4/8] onscreen/native: Split COPY_MODE_SECONDARY_GPU in two

So that the non-blocking part starts immediately (copying between GPUs),
and the blocking part (Nvidia's lock_front_buffer) is deferred until
the sync_fd is signalled.
---
 src/backends/native/meta-onscreen-native.c | 139 ++++++++++++++-------
 1 file changed, 95 insertions(+), 44 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index e85bfec4a44..ebb24cb71f9 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -952,12 +952,11 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
   return imported_buffer;
 }
 
-static MetaDrmBuffer *
-copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
-                             MetaFrameNative                      *frame_native,
-                             MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
-                             MetaRendererNativeGpuData            *renderer_gpu_data,
-                             GError                              **error)
+static int
+start_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                                   MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
+                                   MetaRendererNativeGpuData            *renderer_gpu_data,
+                                   GError                              **error)
 {
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
@@ -967,22 +966,19 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
   MetaRenderDevice *render_device;
   EGLDisplay egl_display;
-  gboolean use_modifiers;
-  MetaDeviceFile *device_file;
-  MetaDrmBufferFlags flags;
   MetaDrmBufferGbm *buffer_gbm = NULL;
   struct gbm_bo *bo;
   EGLSync egl_sync = EGL_NO_SYNC;
-  g_autofd int sync_fd = meta_frame_native_steal_sync_fd (frame_native);
+  g_autofd int sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
   EGLImageKHR egl_image;
   g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
 
-  COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
-                           "copy_shared_framebuffer_gpu()");
+  COGL_TRACE_BEGIN_SCOPED (StartCopySharedFramebufferSecondaryGpu,
+                           "start_copy_shared_framebuffer_gpu()");
 
   primary_gpu_fb = acquire_primary_front_buffer (onscreen, error);
   if (!primary_gpu_fb)
-    return NULL;
+    return -1;
 
   if (!renderer_gpu_data->secondary.needs_explicit_sync)
     g_clear_fd (&sync_fd, NULL);
@@ -1070,7 +1066,39 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
       goto done;
     }
 
-  meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+done:
+  if (egl_sync != EGL_NO_SYNC)
+    {
+      g_autoptr (GError) local_error = NULL;
+
+      if (!meta_egl_destroy_sync (egl,
+                                  egl_display,
+                                  egl_sync,
+                                  &local_error))
+        g_warning ("Failed to destroy secondary GPU EGLSync: %s", local_error->message);
+    }
+
+  _cogl_winsys_egl_ensure_current (cogl_display);
+
+  return g_steal_fd (&sync_fd);
+}
+
+static MetaDrmBuffer *
+finish_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                                    MetaFrameNative                      *frame_native,
+                                    MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
+                                    MetaRendererNativeGpuData            *renderer_gpu_data,
+                                    GError                              **error)
+{
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+  gboolean use_modifiers;
+  MetaDeviceFile *device_file;
+  MetaDrmBufferFlags flags;
+  MetaDrmBufferGbm *buffer_gbm = NULL;
+
+  COGL_TRACE_BEGIN_SCOPED (FinishCopySharedFramebufferSecondaryGpu,
+                           "finish_copy_shared_framebuffer_gpu()");
 
   use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
   device_file = meta_render_device_get_device_file (render_device);
@@ -1085,29 +1113,7 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
                                         flags,
                                         error);
   if (!buffer_gbm)
-    {
-      g_prefix_error (error, "meta_drm_buffer_gbm_new_lock_front failed: ");
-      goto done;
-    }
-
-  g_object_set_qdata_full (G_OBJECT (buffer_gbm),
-                           blit_source_quark,
-                           g_object_ref (primary_gpu_fb),
-                           g_object_unref);
-
-done:
-  if (egl_sync != EGL_NO_SYNC)
-    {
-      g_autoptr (GError) local_error = NULL;
-
-      if (!meta_egl_destroy_sync (egl,
-                                  egl_display,
-                                  egl_sync,
-                                  &local_error))
-        g_warning ("Failed to destroy secondary GPU EGLSync: %s", local_error->message);
-    }
-
-  _cogl_winsys_egl_ensure_current (cogl_display);
+    g_prefix_error (error, "meta_drm_buffer_gbm_new_lock_front failed: ");
 
   return buffer_gbm ? META_DRM_BUFFER (buffer_gbm) : NULL;
 }
@@ -1377,6 +1383,44 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen    *onscreen,
   return copy;
 }
 
+static int
+update_state_post_swap_buffers (CoglOnscreen  *onscreen,
+                                GError       **error)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+  g_autofd int sync_fd = -1;
+
+  secondary_gpu_state = onscreen_native->secondary_gpu_state;
+  if (secondary_gpu_state)
+    {
+      MetaRendererNativeGpuData *renderer_gpu_data;
+
+      renderer_gpu_data = secondary_gpu_state->renderer_gpu_data;
+      switch (renderer_gpu_data->secondary.copy_mode)
+        {
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY:
+          sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+          break;
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
+          sync_fd = start_copy_shared_framebuffer_gpu (onscreen,
+                                                       secondary_gpu_state,
+                                                       renderer_gpu_data,
+                                                       error);
+          break;
+        }
+    }
+  else
+    {
+      sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+    }
+
+  return g_steal_fd (&sync_fd);
+}
+
 static MetaDrmBuffer *
 acquire_front_buffer (CoglOnscreen     *onscreen,
                       MetaFrameNative  *frame_native,
@@ -1421,11 +1465,11 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
         }
       return g_object_ref (secondary_gpu_fb);
     case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
-      return copy_shared_framebuffer_gpu (onscreen,
-                                          frame_native,
-                                          secondary_gpu_state,
-                                          renderer_gpu_data,
-                                          error);
+      return finish_copy_shared_framebuffer_gpu (onscreen,
+                                                 frame_native,
+                                                 secondary_gpu_state,
+                                                 renderer_gpu_data,
+                                                 error);
     }
 
   g_assert_not_reached ();
@@ -1568,9 +1612,16 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                           frame_info,
                                           user_data);
 
-  sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+  sync_fd = update_state_post_swap_buffers (onscreen, &error);
   if (sync_fd >= 0)
-    meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+    {
+      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+    }
+  else if (error != NULL)
+    {
+      g_warning ("update_state_post_swap_buffers failed: %s", error->message);
+      goto swap_failed;
+    }
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
-- 
GitLab


From af7fe6c3b9d86cabf429733fd1d184f1dc23151e Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 7 Aug 2025 17:37:48 +0800
Subject: [PATCH 5/8] onscreen/native: Defer front buffer acquisition until
 ready to post

nvidia-drm needs this because gbm_surface_lock_front_buffer() will block
while rendering is pending. And the GBM docs don't say it needs to be
non-blocking. It would be interesting to find out if other bespoke GBM
implementations (like Xilinx) have the same issue...
---
 src/backends/native/meta-onscreen-native.c | 107 +++++++++++++--------
 1 file changed, 66 insertions(+), 41 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index ebb24cb71f9..e3acf926268 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -84,6 +84,7 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
   gboolean noted_primary_gpu_copy_ok;
   gboolean noted_primary_gpu_copy_failed;
   MetaSharedFramebufferImportStatus import_status;
+  MetaDrmBuffer *source_framebuffer;
 } MetaOnscreenNativeSecondaryGpuState;
 
 typedef struct _KmsProperty
@@ -1574,14 +1575,12 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
-  MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   CoglOnscreenClass *parent_class;
   gboolean secondary_gpu_used = FALSE;
   g_autoptr (GError) error = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
-  g_autoptr (MetaDrmBuffer) buffer = NULL;
   g_autofd int sync_fd = -1;
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
@@ -1595,6 +1594,9 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
     {
       MetaRendererNativeGpuData *secondary_gpu_data;
 
+      g_set_object (&secondary_gpu_state->source_framebuffer,
+                    g_steal_pointer (&secondary_gpu_fb));
+
       secondary_gpu_data =
         meta_renderer_native_get_gpu_data (renderer_native,
                                            secondary_gpu_state->gpu_kms);
@@ -1623,44 +1625,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
       goto swap_failed;
     }
 
-  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
-                                                         render_gpu);
-  switch (renderer_gpu_data->mode)
-    {
-    case META_RENDERER_NATIVE_MODE_GBM:
-      buffer = acquire_front_buffer (onscreen,
-                                     frame_native,
-                                     secondary_gpu_fb,
-                                     &error);
-      if (buffer == NULL)
-        {
-          g_warning ("Failed to acquire front buffer: %s", error->message);
-          goto swap_failed;
-        }
-
-      meta_frame_native_set_buffer (frame_native, buffer);
-
-      if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
-        {
-          MetaRenderDevice *render_device =
-            renderer_gpu_data->render_device;
-          MetaDeviceFile *render_device_file =
-            meta_render_device_get_device_file (render_device);
-
-          g_warning ("Failed to ensure KMS FB ID on %s: %s",
-                     meta_device_file_get_path (render_device_file),
-                     error->message);
-          goto swap_failed;
-        }
-      break;
-    case META_RENDERER_NATIVE_MODE_SURFACELESS:
-      break;
-#ifdef HAVE_EGL_DEVICE
-    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
-      break;
-#endif
-    }
-
   assign_next_frame (onscreen_native, frame);
 
   clutter_frame_set_result (frame,
@@ -1706,8 +1670,10 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
   const MetaKmsResultListenerVtable *listener;
   MetaKmsAssignPlaneFlag flip_flags;
   gboolean is_direct_scanout;
+  gboolean is_swap_buffers;
   MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
   MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  CoglFrameInfo *frame_info;
 
   COGL_TRACE_SCOPED_ANCHOR (MetaRendererNativePostKmsUpdate);
 
@@ -1737,12 +1703,64 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
                                                     kms_device);
 
   is_direct_scanout = meta_frame_native_get_scanout (frame_native) != NULL;
+  is_swap_buffers = meta_frame_native_get_damage (frame_native) != NULL;
+
   if (is_direct_scanout)
     {
       listener = &scanout_result_listener_vtable;
       flip_flags = META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC;
     }
-  else
+  else if (is_swap_buffers)
+    {
+      g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
+      g_autoptr (MetaDrmBuffer) buffer = NULL;
+      g_autoptr (GError) error = NULL;
+      MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+      MetaDeviceFile *render_device_file =
+        meta_render_device_get_device_file (renderer_gpu_data->render_device);
+
+      listener = &swap_buffer_result_listener_vtable;
+      flip_flags = META_KMS_ASSIGN_PLANE_FLAG_NONE;
+
+      secondary_gpu_state = onscreen_native->secondary_gpu_state;
+      if (secondary_gpu_state)
+        {
+          secondary_gpu_fb =
+            g_steal_pointer (&secondary_gpu_state->source_framebuffer);
+        }
+
+      switch (renderer_gpu_data->mode)
+        {
+        case META_RENDERER_NATIVE_MODE_GBM:
+          buffer = acquire_front_buffer (onscreen,
+                                         frame_native,
+                                         secondary_gpu_fb,
+                                         &error);
+          if (buffer == NULL)
+            {
+              g_warning ("Failed to acquire front buffer: %s", error->message);
+              goto post_failed;
+            }
+
+          meta_frame_native_set_buffer (frame_native, buffer);
+
+          if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
+            {
+              g_warning ("Failed to ensure KMS FB ID on %s: %s",
+                         meta_device_file_get_path (render_device_file),
+                         error->message);
+              goto post_failed;
+            }
+          break;
+        case META_RENDERER_NATIVE_MODE_SURFACELESS:
+          break;
+#ifdef HAVE_EGL_DEVICE
+        case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+          break;
+#endif
+        }
+    }
+  else /* property-only update, no framebuffer changes */
     {
       listener = &swap_buffer_result_listener_vtable;
       flip_flags = META_KMS_ASSIGN_PLANE_FLAG_NONE;
@@ -1837,6 +1855,13 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
 
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
+
+  return;
+
+post_failed:
+  frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
+  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
+  meta_onscreen_native_notify_frame_complete (onscreen);
 }
 
 gboolean
-- 
GitLab


From f6ff5b8a64d59c34d7120fc3d4e3bbb39068ca07 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Fri, 17 Oct 2025 13:19:30 +0800
Subject: [PATCH 6/8] backends/native: Add GPollFD functions to MetaFrameNative

---
 src/backends/native/meta-frame-native.c | 47 +++++++++++++++++++++----
 src/backends/native/meta-frame-native.h | 11 ++++++
 2 files changed, 52 insertions(+), 6 deletions(-)

diff --git a/src/backends/native/meta-frame-native.c b/src/backends/native/meta-frame-native.c
index 98cd917c737..76998638554 100644
--- a/src/backends/native/meta-frame-native.c
+++ b/src/backends/native/meta-frame-native.c
@@ -35,7 +35,8 @@ struct _MetaFrameNative
   MetaKmsUpdate *kms_update;
 
   MtkRegion *damage;
-  int sync_fd;
+
+  GPollFD sync;
 };
 
 static void
@@ -43,7 +44,7 @@ meta_frame_native_release (ClutterFrame *frame)
 {
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
 
-  g_clear_fd (&frame_native->sync_fd, NULL);
+  g_clear_fd (&frame_native->sync.fd, NULL);
   g_clear_pointer (&frame_native->damage, mtk_region_unref);
   g_clear_object (&frame_native->buffer);
   g_clear_object (&frame_native->scanout);
@@ -57,7 +58,8 @@ meta_frame_native_new (void)
   MetaFrameNative *frame_native =
     clutter_frame_new (MetaFrameNative, meta_frame_native_release);
 
-  frame_native->sync_fd = -1;
+  frame_native->sync.fd = -1;
+  frame_native->sync.events = 0;
 
   return frame_native;
 }
@@ -139,12 +141,45 @@ void
 meta_frame_native_set_sync_fd (MetaFrameNative *frame_native,
                                int              sync_fd)
 {
-  g_clear_fd (&frame_native->sync_fd, NULL);
-  frame_native->sync_fd = sync_fd;
+  g_clear_fd (&frame_native->sync.fd, NULL);
+  frame_native->sync.fd = sync_fd;
 }
 
 int
 meta_frame_native_steal_sync_fd (MetaFrameNative *frame_native)
 {
-  return g_steal_fd (&frame_native->sync_fd);
+  g_warn_if_fail (frame_native->sync.events == 0);
+
+  return g_steal_fd (&frame_native->sync.fd);
+}
+
+void
+meta_frame_native_add_source (MetaFrameNative *frame_native,
+                              GSource         *source)
+{
+  g_return_if_fail (frame_native->sync.fd >= 0);
+  g_return_if_fail (frame_native->sync.events == 0);
+
+  frame_native->sync.events = G_IO_IN;
+  g_source_add_poll (source, &frame_native->sync);
+}
+
+void
+meta_frame_native_remove_source (MetaFrameNative *frame_native,
+                                 GSource         *source)
+{
+  g_return_if_fail (frame_native->sync.fd >= 0);
+  g_return_if_fail (frame_native->sync.events != 0);
+
+  g_source_remove_poll (source, &frame_native->sync);
+  frame_native->sync.events = 0;
+}
+
+gboolean
+meta_frame_native_is_ready (MetaFrameNative *frame_native)
+{
+  g_return_val_if_fail (frame_native->sync.fd >= 0, FALSE);
+  g_return_val_if_fail (frame_native->sync.events != 0, FALSE);
+
+  return !!(frame_native->sync.revents & G_IO_IN);
 }
diff --git a/src/backends/native/meta-frame-native.h b/src/backends/native/meta-frame-native.h
index 38547ebc1c0..cf736da5f82 100644
--- a/src/backends/native/meta-frame-native.h
+++ b/src/backends/native/meta-frame-native.h
@@ -61,3 +61,14 @@ meta_frame_native_set_sync_fd (MetaFrameNative *frame_native,
 
 int
 meta_frame_native_steal_sync_fd (MetaFrameNative *frame_native);
+
+void
+meta_frame_native_add_source (MetaFrameNative *frame_native,
+                              GSource         *source);
+
+void
+meta_frame_native_remove_source (MetaFrameNative *frame_native,
+                                 GSource         *source);
+
+gboolean
+meta_frame_native_is_ready (MetaFrameNative *frame_native);
-- 
GitLab


From 327a6f2f32c226eb2071c88985c70154fb073b85 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 23 Oct 2025 15:53:44 +0800
Subject: [PATCH 7/8] backends/native: Rename secondary.needs_explicit_sync to
 is_nvidia

No change in functionality, but the flag will soon be used in multiple
locations, not just for controlling explicit sync.
---
 src/backends/native/meta-onscreen-native.c         | 2 +-
 src/backends/native/meta-renderer-native-private.h | 2 +-
 src/backends/native/meta-renderer-native.c         | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index e3acf926268..757ff08f78e 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -981,7 +981,7 @@ start_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscree
   if (!primary_gpu_fb)
     return -1;
 
-  if (!renderer_gpu_data->secondary.needs_explicit_sync)
+  if (!renderer_gpu_data->secondary.is_nvidia)
     g_clear_fd (&sync_fd, NULL);
 
   render_device = renderer_gpu_data->render_device;
diff --git a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
index 9c7887a1efc..3f94c30809b 100644
--- a/src/backends/native/meta-renderer-native-private.h
+++ b/src/backends/native/meta-renderer-native-private.h
@@ -61,7 +61,7 @@ typedef struct _MetaRendererNativeGpuData
     MetaSharedFramebufferCopyMode copy_mode;
     gboolean copy_mode_primary_force_cpu;
     gboolean has_EGL_EXT_image_dma_buf_import_modifiers;
-    gboolean needs_explicit_sync;
+    gboolean is_nvidia;
 
     /* For GPU blit mode */
     EGLContext egl_context;
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 60b8d005c13..78817171253 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -2013,7 +2013,7 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
 
   egl_vendor = meta_egl_query_string (egl, egl_display, EGL_VENDOR);
   if (!g_strcmp0 (egl_vendor, "NVIDIA"))
-    renderer_gpu_data->secondary.needs_explicit_sync = TRUE;
+    renderer_gpu_data->secondary.is_nvidia = TRUE;
 
   ret = TRUE;
 out:
-- 
GitLab


From 3f597c27ee5073ed4e563ce31f6efbf7063bddb0 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 21 Aug 2025 17:12:50 +0800
Subject: [PATCH 8/8] onscreen/native: Add a "render source" signalling GL
 completion

For the composited path, this defers calling maybe_post_next_frame
until the GPU signals that rendering is actually finished. On nvidia-drm,
doing so avoids spending milliseconds blocked inside
`gbm_surface_lock_front_buffer` each frame. But the problem is not
provably limited to Nvidia since the GBM docs are vague enough that
we may expect the same issue in other bespoke GBM implementations.

Since Mesa DRI drivers are always non-blocking in `lock_front_buffer`,
the new path is only enabled for nvidia-drm at the moment. In theory the
DRI drivers can already achieve higher performance by not having to defer
the post in userspace. In practice we don't see any performance
difference on drivers other than Nvidia.

Mostly solves https://gitlab.gnome.org/GNOME/mutter/-/issues/3461, where
the amount of time blocked inside `gbm_surface_lock_front_buffer` has been
reduced by:
 - 99% for the single GPU case
 - 99% for the double-buffering hybrid GPU case
 - 50% for the triple-buffering hybrid GPU case (needs more work)
---
 src/backends/native/meta-onscreen-native.c | 261 ++++++++++++++++++++-
 1 file changed, 252 insertions(+), 9 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 757ff08f78e..c8315e32cef 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -87,6 +87,13 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
   MetaDrmBuffer *source_framebuffer;
 } MetaOnscreenNativeSecondaryGpuState;
 
+typedef struct _RenderSource
+{
+  GSource source;
+  MetaOnscreenNative *onscreen_native;
+  GHashTable *frames;
+} RenderSource;
+
 typedef struct _KmsProperty
 {
   gboolean invalidated;
@@ -129,6 +136,8 @@ struct _MetaOnscreenNative
 
   MetaRendererView *view;
 
+  GSource *render_source;
+
   union {
     struct {
       KmsProperty gamma_lut;
@@ -156,6 +165,194 @@ init_secondary_gpu_state (MetaRendererNative  *renderer_native,
                           CoglOnscreen        *onscreen,
                           GError             **error);
 
+static MetaEgl *
+meta_onscreen_native_get_egl (MetaOnscreenNative *onscreen_native);
+
+static void
+render_source_remove_frame (GSource      *source,
+                            ClutterFrame *frame)
+{
+  RenderSource *render_source;
+
+  if (!source || !frame)
+    return;
+
+  render_source = (RenderSource *) source;
+  if (g_hash_table_contains (render_source->frames, frame))
+    {
+      MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
+
+      meta_frame_native_remove_source (frame_native, source);
+      g_hash_table_remove (render_source->frames, frame);
+    }
+}
+
+static void
+render_source_add_frame (GSource      *source,
+                         ClutterFrame *frame)
+{
+  RenderSource *render_source;
+  MetaFrameNative *frame_native;
+
+  g_return_if_fail (source != NULL);
+  g_return_if_fail (frame != NULL);
+
+  render_source = (RenderSource *) source;
+  g_return_if_fail (!g_hash_table_contains (render_source->frames, frame));
+
+  frame_native = meta_frame_native_from_frame (frame);
+  meta_frame_native_add_source (frame_native, source);
+  g_hash_table_insert (render_source->frames, clutter_frame_ref (frame), NULL);
+}
+
+static gboolean
+render_source_ready (GSource *source)
+{
+  RenderSource *render_source = (RenderSource *) source;
+  MetaOnscreenNative *onscreen_native = render_source->onscreen_native;
+  ClutterFrame *frame = onscreen_native->next_frame;
+  MetaFrameNative *frame_native;
+
+  if (frame == NULL)
+    return FALSE;
+
+  if (!g_hash_table_contains (render_source->frames, frame))
+    return FALSE;
+
+  frame_native = meta_frame_native_from_frame (frame);
+  return meta_frame_native_is_ready (frame_native);
+}
+
+static void
+maybe_post_next_frame_if_gl_finished (CoglOnscreen *onscreen)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  RenderSource *render_source = (RenderSource *) onscreen_native->render_source;
+  ClutterFrame *frame = onscreen_native->next_frame;
+
+  if (frame == NULL)
+    return;
+
+  if (render_source &&
+      g_hash_table_contains (render_source->frames, frame) &&
+      !meta_frame_native_is_ready (meta_frame_native_from_frame (frame)))
+    {
+      return;
+    }
+
+  maybe_post_next_frame (onscreen);
+}
+
+static gboolean
+render_source_prepare (GSource *source,
+                       gint    *timeout_ms)
+{
+  *timeout_ms = -1;
+
+  return render_source_ready (source);
+}
+
+static gboolean
+render_source_check (GSource *source)
+{
+  return render_source_ready (source);
+}
+
+static gboolean
+render_source_dispatch (GSource     *source,
+                        GSourceFunc  callback,
+                        gpointer     user_data)
+{
+  if (callback)
+    callback (user_data);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static void
+render_source_finalize (GSource *source)
+{
+  RenderSource *render_source = (RenderSource *) source;
+
+  g_clear_pointer (&render_source->frames, g_hash_table_destroy);
+}
+
+static void
+maybe_init_render_source (MetaOnscreenNative *onscreen_native)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen_native);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  const char *force_render_source;
+  gboolean use_render_source;
+
+  force_render_source = g_getenv ("MUTTER_DEBUG_FORCE_RENDER_SOURCE");
+  if (force_render_source != NULL)
+    {
+      use_render_source = g_strcmp0 (force_render_source, "0") != 0;
+    }
+  else
+    {
+      MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state =
+        onscreen_native->secondary_gpu_state;
+      gboolean output_gpu_is_nvidia;
+
+      if (secondary_gpu_state)
+        {
+          MetaRendererNativeGpuData *renderer_gpu_data =
+            secondary_gpu_state->renderer_gpu_data;
+
+          output_gpu_is_nvidia = renderer_gpu_data->secondary.is_nvidia;
+        }
+      else
+        {
+          MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
+          EGLDisplay egl_display = cogl_context_get_egl_display (cogl_context);
+          const char *egl_vendor =
+            meta_egl_query_string (egl, egl_display, EGL_VENDOR);
+          output_gpu_is_nvidia =
+            g_strcmp0 (egl_vendor, "NVIDIA") == 0;
+        }
+
+      use_render_source = output_gpu_is_nvidia;
+    }
+
+  if (use_render_source)
+    {
+      static GSourceFuncs render_source_funcs = {
+        .prepare = render_source_prepare,
+        .check = render_source_check,
+        .dispatch = render_source_dispatch,
+        .finalize = render_source_finalize,
+      };
+      GSource *source;
+      RenderSource *render_source;
+
+      if (!cogl_context_has_feature (cogl_context,
+                                     COGL_FEATURE_ID_SYNC_FD))
+        {
+          g_warning ("Render source feature was requested but is disabled "
+                     "due to lack of driver support.");
+          return;
+        }
+
+      source = g_source_new (&render_source_funcs, sizeof (RenderSource));
+      onscreen_native->render_source = source;
+      render_source = (RenderSource *) source;
+      render_source->frames = g_hash_table_new_full (g_direct_hash,
+                                                     g_direct_equal,
+                                                     (GDestroyNotify) clutter_frame_unref,
+                                                     NULL);
+      render_source->onscreen_native = onscreen_native;
+      g_source_set_name (source, "MetaOnscreenNative.render_source");
+      g_source_set_can_recurse (source, FALSE);
+      g_source_set_callback (source,
+                             (GSourceFunc) maybe_post_next_frame_if_gl_finished,
+                             onscreen_native,
+                             NULL);
+      g_source_attach (source, NULL);
+    }
+}
+
 static void
 meta_onscreen_native_promote_posted_frame (CoglOnscreen *onscreen)
 {
@@ -263,7 +460,7 @@ notify_view_crtc_presented (MetaRendererView *view,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_promote_posted_frame (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static void
@@ -320,7 +517,7 @@ page_flip_feedback_ready (MetaKmsCrtc *kms_crtc,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_promote_posted_frame (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static void
@@ -388,7 +585,7 @@ page_flip_feedback_discarded (MetaKmsCrtc  *kms_crtc,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_clear_posted_fb (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static const MetaKmsPageFlipListenerVtable page_flip_listener_vtable = {
@@ -1541,6 +1738,8 @@ assign_next_frame (MetaOnscreenNative *onscreen_native,
 
   if (onscreen_native->next_frame != NULL)
     {
+      render_source_remove_frame (onscreen_native->render_source,
+                                  onscreen_native->next_frame);
       clear_superseded_frame (onscreen);
       onscreen_native->superseded_frame =
         g_steal_pointer (&onscreen_native->next_frame);
@@ -1586,6 +1785,34 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
                            "Meta::OnscreenNative::swap_buffers_with_damage()");
 
+  if (onscreen_native->next_frame != NULL)
+    {
+      /* This is the slow path (though still faster than what came before it)
+       * because it bypasses the render_source. It's here for two reasons:
+       *  1. Nvidia's eglSwapBuffers will deadlock unless paired perfectly
+       *     with the same number of gbm_surface_lock_front_buffer calls.
+       *     Mesa does not seem to have this issue and allows more swaps than
+       *     locks (has more buffers?).
+       *  2. AMDGPU doesn't deadlock but would result in a frame drop causing
+       *     stutter if assign_next_frame is called without allowing another
+       *     attempt at maybe_post_next_frame first.
+       *
+       * We only seem to arrive here frequently when using
+       * COPY_MODE_SECONDARY_GPU. This suggests there's a unique timing issue
+       * causing the third buffer to be scheduled too early. Though to be fair,
+       * dual-GPU render times are also longer which means the latest frame
+       * will be scheduled early in an attempt to catch up.
+       *
+       * Disabling the render source, or disabling triple buffering avoids
+       * this path, but also results in noticeably lower performance.
+       */
+      maybe_post_next_frame (onscreen);
+
+      g_warn_if_fail (onscreen_native->next_frame == NULL);
+      if (onscreen_native->next_frame != NULL)
+        goto swap_failed;
+    }
+
   secondary_gpu_fb =
     update_secondary_gpu_state_pre_swap_buffers (onscreen, region);
 
@@ -1615,11 +1842,7 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                           user_data);
 
   sync_fd = update_state_post_swap_buffers (onscreen, &error);
-  if (sync_fd >= 0)
-    {
-      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
-    }
-  else if (error != NULL)
+  if (sync_fd < 0 && error != NULL)
     {
       g_warning ("update_state_post_swap_buffers failed: %s", error->message);
       goto swap_failed;
@@ -1632,7 +1855,19 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
   meta_frame_native_set_damage (frame_native, region);
 
-  maybe_post_next_frame (onscreen);
+  if (sync_fd >= 0)
+    {
+      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+      if (onscreen_native->render_source)
+        render_source_add_frame (onscreen_native->render_source, frame);
+      else
+        maybe_post_next_frame (onscreen);
+    }
+  else
+    {
+      maybe_post_next_frame (onscreen);
+    }
+
   return;
 
 swap_failed:
@@ -1691,6 +1926,8 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
       return;
     }
 
+  render_source_remove_frame (onscreen_native->render_source,
+                              onscreen_native->next_frame);
   frame = g_steal_pointer (&onscreen_native->next_frame);
   frame_native = meta_frame_native_from_frame (frame);
   region = meta_frame_native_get_damage (frame_native);
@@ -2309,6 +2546,9 @@ meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen)
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
   discard_pending_swap (&onscreen_native->superseded_frame);
+
+  render_source_remove_frame (onscreen_native->render_source,
+                              onscreen_native->next_frame);
   discard_pending_swap (&onscreen_native->next_frame);
 }
 
@@ -2733,6 +2973,8 @@ meta_onscreen_native_allocate (CoglFramebuffer  *framebuffer,
         return FALSE;
     }
 
+  maybe_init_render_source (onscreen_native);
+
   width = cogl_framebuffer_get_width (framebuffer);
   height = cogl_framebuffer_get_height (framebuffer);
 
@@ -3142,6 +3384,7 @@ meta_onscreen_native_dispose (GObject *object)
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
   MetaRendererNativeGpuData *renderer_gpu_data;
 
+  g_clear_pointer (&onscreen_native->render_source, g_source_destroy);
   meta_onscreen_native_detach (onscreen_native);
 
   meta_onscreen_native_discard_pending_swaps (onscreen);
-- 
GitLab

